<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"thisiswilli.cn","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="flink源码阅读之JobGraph的生成过程本文结合源码介绍flink中JobGraph的生成过程，flink版本为flink1.11">
<meta property="og:type" content="article">
<meta property="og:title" content="flink源码阅读之JobGraph的生成过程">
<meta property="og:url" content="https://thisiswilli.cn/2020/07/25/flink%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BJobGraph%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="ThisisWilli">
<meta property="og:description" content="flink源码阅读之JobGraph的生成过程本文结合源码介绍flink中JobGraph的生成过程，flink版本为flink1.11">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://willipic.oss-cn-hangzhou.aliyuncs.com/Flink/JobGraph%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://willipic.oss-cn-hangzhou.aliyuncs.com/Flink/%E7%94%9F%E6%88%90JobGraph%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://willipic.oss-cn-hangzhou.aliyuncs.com/Flink/JobVertex%E5%92%8CJobEdge%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png">
<meta property="article:published_time" content="2020-07-25T15:17:27.000Z">
<meta property="article:modified_time" content="2020-08-25T15:27:17.229Z">
<meta property="article:author" content="Willi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://willipic.oss-cn-hangzhou.aliyuncs.com/Flink/JobGraph%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png">

<link rel="canonical" href="https://thisiswilli.cn/2020/07/25/flink%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BJobGraph%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>flink源码阅读之JobGraph的生成过程 | ThisisWilli</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0dc46e5d0914c07dc8b23b28c12d8fb3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="ThisisWilli" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ThisisWilli</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Time is now</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">19</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thisiswilli.cn/2020/07/25/flink%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BJobGraph%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/xiaolang.jpeg">
      <meta itemprop="name" content="Willi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThisisWilli">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          flink源码阅读之JobGraph的生成过程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-25 23:17:27" itemprop="dateCreated datePublished" datetime="2020-07-25T23:17:27+08:00">2020-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-25 23:27:17" itemprop="dateModified" datetime="2020-08-25T23:27:17+08:00">2020-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flink/" itemprop="url" rel="index"><span itemprop="name">Flink</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/07/25/flink%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BJobGraph%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/07/25/flink%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BJobGraph%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="flink源码阅读之JobGraph的生成过程"><a href="#flink源码阅读之JobGraph的生成过程" class="headerlink" title="flink源码阅读之JobGraph的生成过程"></a>flink源码阅读之JobGraph的生成过程</h1><p>本文结合源码介绍flink中JobGraph的生成过程，flink版本为flink1.11</p>
<a id="more"></a>
<p>flink job在最初会生成一个StreamGraph，然而StreamGraph只是程序初步得到的一个数据链路，根据算子的并行度等因素还能优化成为JobGraph。<strong>JobGraph的存在主要是为了兼容batch process</strong>，Streaming process最初产生的是StreamGraph，而batch process产生的则是OptimizedPlan，他们最后都会转化为JobGraph。</p>
<h2 id="生成JobGraph的整体流程"><a href="#生成JobGraph的整体流程" class="headerlink" title="生成JobGraph的整体流程"></a>生成JobGraph的整体流程</h2><h3 id="从StreamGraph到JobGraph的转化步骤"><a href="#从StreamGraph到JobGraph的转化步骤" class="headerlink" title="从StreamGraph到JobGraph的转化步骤"></a>从StreamGraph到JobGraph的转化步骤</h3><ol>
<li><p>设置调度模式，Eager 所有节点立即启动。</p>
</li>
<li><p><strong>广度优先遍历 StreamGraph</strong>，为每个 streamNode 生成 byte 数组类型的 hash 值。</p>
</li>
<li><p>从 source 节点开始递归寻找嵌到一起的 operator，不能嵌到一起的节点单独生成 jobVertex，能够嵌到一起的开始节点生成 jobVertex，其他节点以序列化的形式写入到 StreamConfig，然后 merge 到 CHAINED_TASK_CONFIG，再通过 JobEdge 链接上下游 JobVertex。</p>
</li>
<li><p>将每个 JobVertex 的入边(StreamEdge)序列化到该 StreamConfig。</p>
</li>
<li><p>根据 group name 为每个 JobVertext 指定 SlotSharingGroup。</p>
</li>
<li><p>配置 checkpoint。</p>
</li>
<li><p>将缓存文件存文件的配置添加到 configuration 中。</p>
</li>
<li><p>设置 ExecutionConfig。</p>
</li>
</ol>
<p>如果以local model执行flink任务，源码层面的方法调用流程如下所示</p>
<img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Flink/JobGraph%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" style="zoom:70%;" />

<p>StreamGraph转化为JobGraph的重点步骤主要在StreamingJobGraphGenerator文件中，这一部分的方法调用流程如下</p>
<p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Flink/%E7%94%9F%E6%88%90JobGraph%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B.png" alt=""></p>
<p>看一下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> JobGraph <span class="title">createJobGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		preValidate();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// make sure that all vertices start immediately</span></span><br><span class="line">		jobGraph.setScheduleMode(streamGraph.getScheduleMode());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate deterministic hashes for the nodes in order to identify them across</span></span><br><span class="line">		<span class="comment">// submission iff they didn't change.</span></span><br><span class="line">		Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes = defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate legacy version hashes for backwards compatibility</span></span><br><span class="line">		List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes = <span class="keyword">new</span> ArrayList&lt;&gt;(legacyStreamGraphHashers.size());</span><br><span class="line">		<span class="keyword">for</span> (StreamGraphHasher hasher : legacyStreamGraphHashers) &#123;</span><br><span class="line">			legacyHashes.add(hasher.traverseStreamGraphAndGenerateHashes(streamGraph));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 方法将可以 Chain 到一起的 StreamNode Chain 在一起，这里会生成相应的 JobVertex 、JobEdge 、 IntermediateDataSet 对象，JobGraph 的 Graph 在这一步就已经完全构建出来了；</span></span><br><span class="line">		setChaining(hashes, legacyHashes);</span><br><span class="line">		<span class="comment">// 方法会将每个 JobVertex 的入边集合也序列化到该 JobVertex 的 StreamConfig 中 (出边集合已经在 setChaining 的时候写入了)；</span></span><br><span class="line">		setPhysicalEdges();</span><br><span class="line">		<span class="comment">// 方法主要是 JobVertex 的 SlotSharingGroup 和 CoLocationGroup 设置；</span></span><br><span class="line">		setSlotSharingAndCoLocation();</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		setManagedMemoryFraction(</span><br><span class="line">			Collections.unmodifiableMap(jobVertices),</span><br><span class="line">			Collections.unmodifiableMap(vertexConfigs),</span><br><span class="line">			Collections.unmodifiableMap(chainedConfigs),</span><br><span class="line">			id -&gt; streamGraph.getStreamNode(id).getMinResources(),</span><br><span class="line">			id -&gt; streamGraph.getStreamNode(id).getManagedMemoryWeight());</span><br><span class="line">		<span class="comment">// 方法主要是 checkpoint 相关的设置。</span></span><br><span class="line">		configureCheckpointing();</span><br><span class="line"></span><br><span class="line">		jobGraph.setSavepointRestoreSettings(streamGraph.getSavepointRestoreSettings());</span><br><span class="line"></span><br><span class="line">		JobGraphUtils.addUserArtifactEntries(streamGraph.getUserArtifacts(), jobGraph);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// set the ExecutionConfig last when it has been finalized</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			jobGraph.setExecutionConfig(streamGraph.getExecutionConfig());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalConfigurationException(<span class="string">"Could not serialize the ExecutionConfig."</span> +</span><br><span class="line">					<span class="string">"This indicates that non-serializable types (like custom serializers) were registered"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> jobGraph;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为每个operator生成hash值"><a href="#为每个operator生成hash值" class="headerlink" title="为每个operator生成hash值"></a>为每个operator生成hash值</h3><p>在<code>createJobGraph()</code>方法中，<code>traverseStreamGraphAndGenerateHashes()</code>方法为每个operator生成hash</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes = defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br></pre></td></tr></table></figure>

<p>如果用户对节点指定了一个散列值，则基于用户指定的值能够产生一个长度为 16 的字节数组。如果用户没有指定，则根据当前节点所处的位置，产生一个散列值。</p>
<p><strong>为每个operator生成hash的原因</strong></p>
<p>Flink 任务失败的时候，各个 operator 是能够从 checkpoint 中恢复到失败之前的状态的，恢复的时候是依据 JobVertexID（hash 值)进行状态恢复的。相同的任务在恢复的时候要求 operator 的 hash 值不变，因此能够获取对应的状态。</p>
<h3 id="setChaining-—判断算子能否chain在一起"><a href="#setChaining-—判断算子能否chain在一起" class="headerlink" title="setChaining() —判断算子能否chain在一起"></a>setChaining() —判断算子能否chain在一起</h3><p><code>setChaining()</code>方法用来将StreamNode chain一起，该方法最终会调用<code>createChain()</code>方法，先分析源码，再解析具体步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChaining</span><span class="params">(Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes, List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Integer sourceNodeId : streamGraph.getSourceIDs()) &#123;</span><br><span class="line">			createChain(	<span class="comment">// 处理每个source StreamNode</span></span><br><span class="line">					sourceNodeId,</span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					<span class="keyword">new</span> OperatorChainInfo(sourceNodeId, hashes, legacyHashes, streamGraph));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;StreamEdge&gt; <span class="title">createChain</span><span class="params">(Integer currentNodeId, <span class="keyword">int</span> chainIndex, OperatorChainInfo chainInfo)</span> </span>&#123;</span><br><span class="line">		Integer startNodeId = chainInfo.getStartNodeId();</span><br><span class="line">		<span class="keyword">if</span> (!builtVertices.contains(startNodeId)) &#123;</span><br><span class="line">			<span class="comment">// 当前operator chain的最终的输出边，不包括内部的边</span></span><br><span class="line">			List&lt;StreamEdge&gt; transitiveOutEdges = <span class="keyword">new</span> ArrayList&lt;StreamEdge&gt;();</span><br><span class="line">			<span class="comment">// 以Edge为粒度，计算上下游能chain在一起的Edge</span></span><br><span class="line">			List&lt;StreamEdge&gt; chainableOutputs = <span class="keyword">new</span> ArrayList&lt;StreamEdge&gt;();</span><br><span class="line">			List&lt;StreamEdge&gt; nonChainableOutputs = <span class="keyword">new</span> ArrayList&lt;StreamEdge&gt;();</span><br><span class="line">			<span class="comment">// 获得当前要处理的StreamNode</span></span><br><span class="line">			StreamNode currentNode = streamGraph.getStreamNode(currentNodeId);</span><br><span class="line">			<span class="comment">// 遍历当前StreamNode的输出节点，判断哪些输出节点能chain</span></span><br><span class="line">			<span class="keyword">for</span> (StreamEdge outEdge : currentNode.getOutEdges()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isChainable(outEdge, streamGraph)) &#123;</span><br><span class="line">					chainableOutputs.add(outEdge);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					nonChainableOutputs.add(outEdge);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 对于chainable的输出边，递归调用，找到最终的输出边并加入到输出列表中</span></span><br><span class="line">			<span class="keyword">for</span> (StreamEdge chainable : chainableOutputs) &#123;</span><br><span class="line">				transitiveOutEdges.addAll( <span class="comment">// 递归调用，能chain在一起的话，chainIndex会+1</span></span><br><span class="line">						createChain(chainable.getTargetId(), chainIndex + <span class="number">1</span>, chainInfo));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (StreamEdge nonChainable : nonChainableOutputs) &#123;</span><br><span class="line">				transitiveOutEdges.add(nonChainable); <span class="comment">// 这个边不管能不能连接，都应该添加到输出列表中</span></span><br><span class="line">				createChain(nonChainable.getTargetId(), <span class="number">0</span>, chainInfo.newChain(nonChainable.getTargetId()));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			chainedNames.put(currentNodeId, createChainedName(currentNodeId, chainableOutputs)); <span class="comment">// 记录chainedName</span></span><br><span class="line">			chainedMinResources.put(currentNodeId, createChainedMinResources(currentNodeId, chainableOutputs)); <span class="comment">// 计算Chain之后node的minResources</span></span><br><span class="line">			chainedPreferredResources.put(currentNodeId, createChainedPreferredResources(currentNodeId, chainableOutputs)); <span class="comment">// 计算Chain之后node的资源上限</span></span><br><span class="line">			<span class="comment">// addNodeToChain 用于保存一个operator chain中所有operator的hash信息</span></span><br><span class="line">			OperatorID currentOperatorId = chainInfo.addNodeToChain(currentNodeId, chainedNames.get(currentNodeId));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (currentNode.getInputFormat() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				getOrCreateFormatContainer(startNodeId).addInputFormat(currentOperatorId, currentNode.getInputFormat());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (currentNode.getOutputFormat() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				getOrCreateFormatContainer(startNodeId).addOutputFormat(currentOperatorId, currentNode.getOutputFormat());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果当前节点为起始节点，直接创建JobVertex，如果不是，则先创建一个Stream Config</span></span><br><span class="line">			StreamConfig config = currentNodeId.equals(startNodeId)</span><br><span class="line">					? createJobVertex(startNodeId, chainInfo)</span><br><span class="line">					: <span class="keyword">new</span> StreamConfig(<span class="keyword">new</span> Configuration());</span><br><span class="line">			<span class="comment">// 设置 JobVertex 的 StreamConfig, 基本上是将 StreamNode 中的配置设置到 StreamConfig 中</span></span><br><span class="line">			setVertexConfig(currentNodeId, config, chainableOutputs, nonChainableOutputs);</span><br><span class="line">			<span class="comment">// 走到这里，说明chain已经完成</span></span><br><span class="line">			<span class="keyword">if</span> (currentNodeId.equals(startNodeId)) &#123;</span><br><span class="line"></span><br><span class="line">				config.setChainStart();</span><br><span class="line">				config.setChainIndex(<span class="number">0</span>);</span><br><span class="line">				config.setOperatorName(streamGraph.getStreamNode(currentNodeId).getOperatorName());</span><br><span class="line">				config.setOutEdgesInOrder(transitiveOutEdges);</span><br><span class="line">				config.setOutEdges(streamGraph.getStreamNode(currentNodeId).getOutEdges());</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (StreamEdge edge : transitiveOutEdges) &#123;</span><br><span class="line">					connect(startNodeId, edge);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 将chain中所有子节点的StreamConfig写入的headOfChain节点的CHAINED_TASK_CONFIG 配置中</span></span><br><span class="line">				config.setTransitiveChainedTaskConfigs(chainedConfigs.get(startNodeId));</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				chainedConfigs.computeIfAbsent(startNodeId, k -&gt; <span class="keyword">new</span> HashMap&lt;Integer, StreamConfig&gt;()); <span class="comment">// 如果是chain中子节点</span></span><br><span class="line"></span><br><span class="line">				config.setChainIndex(chainIndex);</span><br><span class="line">				StreamNode node = streamGraph.getStreamNode(currentNodeId);</span><br><span class="line">				config.setOperatorName(node.getOperatorName());</span><br><span class="line">				chainedConfigs.get(startNodeId).put(currentNodeId, config); <span class="comment">// 将当前 StreamNode 的 config 记录到该 chain 的 config 集合中</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			config.setOperatorID(currentOperatorId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (chainableOutputs.isEmpty()) &#123;</span><br><span class="line">				config.setChainEnd();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> transitiveOutEdges;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在执行<code>createChain</code>方法时，它首先从会遍历这个 StreamGraph 的 source 节点，然后选择从 source 节点开始执行 <code>createChain()</code> 方法，在具体的实现里，主要逻辑如下：</p>
<ol>
<li><code>createChain()</code> 当前要处理的节点是 <code>currentNodeId</code>，先从 StreamGraph 中拿到这个 StreamNode 的 outEdge（<code>currentNode.getOutEdges()</code>），然后判断这个 outEdge 连接的两个 StreamNode 是否可以 Chain 在一起，判断方法是 <code>isChainable()</code>；</li>
<li>紧接着会有一个<strong>递归调用</strong>：<ul>
<li>对于可以 Chain 在一起的 StreamEdge（这个 Edge 连接两个 StreamNode 是可以 Chain 在一起），会再次调用 <code>createChain()</code> 方法，并且 <code>createChain()</code> 中的 <code>startNodeId</code> 还是最开始的 <code>startNodeId</code>（这个标识了这个 ChainNode 的开始 NodeId），而 <code>chainIndex</code> 会自增加 1；</li>
<li>而对于不能 Chain 在一起的 StreamEdge，<code>createChain()</code> 中的 <code>startNodeId</code> 变成了这个 StreamEdge 的 target StreamNode（相当于如果 Chain 在一起，ChainNode 中的 startNodeId 会赋值为下一个节点的 NodeId，然后再依次类推），<code>chainIndex</code> 又从 0 开始计；</li>
<li>也就是说：<code>createChain()</code> 中的 <code>startNodeId</code> 表示了当前可以 Chain 之后 Node 的 startId，这里，会一直递归调用，直到达到 Sink 节点。</li>
</ul>
</li>
<li>然后在生成 <code>StreamConfig</code> 对象时，判断当前的 <code>currentNodeId</code> 与 <code>startNodeId</code> 是否相等，如果相等的话，证明当前 Node 就是这个 ChainNode 的 StartNode，这里会调用 <code>createJobVertex()</code> 方法给这个 ChainNode 创建一个 JobVertex 对象，最后会返回一个 StreamConfig 对象，如果前面的 id 不相等的话，这里会直接返回一个 StreamConfig 对象（这个对象主要是记录当前 StreamNode 的一些配置，它会同步 StreamGraph 中相关的配置）；</li>
<li>最后还会分两种情况判断：<ul>
<li>如果 id 相等，相当于这个 ChainNode 已经完成，先做一些相关的配置（比如：标识当前 StreamNode 为这个 JobVertex 的起始 node），最后再通过 <code>connect()</code> 方法创建 JobEdge 和 IntermediateDataSet 对象，把这个 Graph 连接起来；</li>
<li>如果 id 不相等，那么证明当前 StreamNode 只是这个 Chain的一部分，这里只是同步一下信息，并记录到缓存。</li>
</ul>
</li>
</ol>
<h4 id="判断两个StreamNode能否chain"><a href="#判断两个StreamNode能否chain" class="headerlink" title="判断两个StreamNode能否chain"></a>判断两个StreamNode能否chain</h4><p>判断两个StreamNode能够chain，需要符合以下几个条件</p>
<ol>
<li>对应下游Vertex的入读只有1。</li>
<li>上游Vertex和下游Vertex在一个共享的slot中。</li>
<li>edge 的分区函数是 ForwardPartitioner 的实例。ForwardPartitioner分区器要求上下游算子并行度一样。上下游Operator同属一个SubTasks。关于flink的8大分区，可以<a href="https://blog.csdn.net/wangpei1949/article/details/100631663" target="_blank" rel="noopener">参考</a></li>
<li>任务不是流式任务</li>
<li>上下游算子并行度相同</li>
<li>StreamGraph是否允许连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChainable</span><span class="params">(StreamEdge edge, StreamGraph streamGraph)</span> </span>&#123;</span><br><span class="line">		StreamNode upStreamVertex = streamGraph.getSourceVertex(edge);</span><br><span class="line">		StreamNode downStreamVertex = streamGraph.getTargetVertex(edge);</span><br><span class="line">		<span class="keyword">return</span> downStreamVertex.getInEdges().size() == <span class="number">1</span></span><br><span class="line">				&amp;&amp; upStreamVertex.isSameSlotSharingGroup(downStreamVertex)</span><br><span class="line">				&amp;&amp; areOperatorsChainable(upStreamVertex, downStreamVertex, streamGraph)</span><br><span class="line">				&amp;&amp; (edge.getPartitioner() <span class="keyword">instanceof</span> ForwardPartitioner)</span><br><span class="line">				&amp;&amp; edge.getShuffleMode() != ShuffleMode.BATCH</span><br><span class="line">				&amp;&amp; upStreamVertex.getParallelism() == downStreamVertex.getParallelism()</span><br><span class="line">				&amp;&amp; streamGraph.isChainingEnabled();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createJobVertex-创建JobVertex"><a href="#createJobVertex-创建JobVertex" class="headerlink" title="createJobVertex()创建JobVertex"></a>createJobVertex()创建JobVertex</h4><p>源码如下，根据chainInfo与StreamNode创建JobVertex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> StreamConfig <span class="title">createJobVertex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Integer streamNodeId,</span></span></span><br><span class="line"><span class="function"><span class="params">			OperatorChainInfo chainInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		JobVertex jobVertex;</span><br><span class="line">		StreamNode streamNode = streamGraph.getStreamNode(streamNodeId);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">byte</span>[] hash = chainInfo.getHash(streamNodeId);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hash == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot find node hash. "</span> +</span><br><span class="line">					<span class="string">"Did you generate them before calling this method?"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		JobVertexID jobVertexId = <span class="keyword">new</span> JobVertexID(hash);</span><br><span class="line"></span><br><span class="line">		List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt; chainedOperators = chainInfo.getChainedOperatorHashes(streamNodeId);</span><br><span class="line">		List&lt;OperatorIDPair&gt; operatorIDPairs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (chainedOperators != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; chainedOperator : chainedOperators) &#123;</span><br><span class="line">				OperatorID userDefinedOperatorID = chainedOperator.f1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> OperatorID(chainedOperator.f1);</span><br><span class="line">				operatorIDPairs.add(OperatorIDPair.of(<span class="keyword">new</span> OperatorID(chainedOperator.f0), userDefinedOperatorID));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (chainedInputOutputFormats.containsKey(streamNodeId)) &#123;</span><br><span class="line">			jobVertex = <span class="keyword">new</span> InputOutputFormatVertex(</span><br><span class="line">					chainedNames.get(streamNodeId),</span><br><span class="line">					jobVertexId,</span><br><span class="line">					operatorIDPairs);</span><br><span class="line"></span><br><span class="line">			chainedInputOutputFormats</span><br><span class="line">				.get(streamNodeId)</span><br><span class="line">				.write(<span class="keyword">new</span> TaskConfig(jobVertex.getConfiguration()));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			jobVertex = <span class="keyword">new</span> JobVertex(</span><br><span class="line">					chainedNames.get(streamNodeId),</span><br><span class="line">					jobVertexId,</span><br><span class="line">					operatorIDPairs);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (OperatorCoordinator.Provider coordinatorProvider : chainInfo.getCoordinatorProviders()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				jobVertex.addOperatorCoordinator(<span class="keyword">new</span> SerializedValue&lt;&gt;(coordinatorProvider));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> FlinkRuntimeException(String.format(</span><br><span class="line">						<span class="string">"Coordinator Provider for node %s is not serializable."</span>, chainedNames.get(streamNodeId)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jobVertex.setResources(chainedMinResources.get(streamNodeId), chainedPreferredResources.get(streamNodeId));</span><br><span class="line"></span><br><span class="line">		jobVertex.setInvokableClass(streamNode.getJobVertexClass());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> parallelism = streamNode.getParallelism();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (parallelism &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			jobVertex.setParallelism(parallelism);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			parallelism = jobVertex.getParallelism();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jobVertex.setMaxParallelism(streamNode.getMaxParallelism());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">			LOG.debug(<span class="string">"Parallelism set: &#123;&#125; for &#123;&#125;"</span>, parallelism, streamNodeId);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> inherit InputDependencyConstraint from the head operator</span></span><br><span class="line">		jobVertex.setInputDependencyConstraint(streamGraph.getExecutionConfig().getDefaultInputDependencyConstraint());</span><br><span class="line"></span><br><span class="line">		jobVertices.put(streamNodeId, jobVertex);</span><br><span class="line">		builtVertices.add(streamNodeId);</span><br><span class="line">		jobGraph.addVertex(jobVertex);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StreamConfig(jobVertex.getConfiguration());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="connect-将JobVertex与JobEdge连接在一起"><a href="#connect-将JobVertex与JobEdge连接在一起" class="headerlink" title="connect()-将JobVertex与JobEdge连接在一起"></a>connect()-将JobVertex与JobEdge连接在一起</h4><ul>
<li><p>JobVertex：经过优化后符合条件的多个StreamNode可能会chain在一起生成一个JobVertex，即一个JobVertex包含一个或多个operator，JobVertex的输入是JobEdge，输出是IntermediateDataSet。</p>
</li>
<li><p>IntermediateDataSet：表示JobVertex的输出，即经过operator处理产生的数据集。producer是JobVertex，consumer是JobEdge。</p>
</li>
<li><p>JobEdge：代表了job graph中的一条数据传输通道。source 是 IntermediateDataSet，target 是 JobVertex。即数据通过JobEdge由IntermediateDataSet传递给目标JobVertex。</p>
</li>
</ul>
<p>JobVertex与JobEdge的联系如下图所示</p>
<img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Flink/JobVertex%E5%92%8CJobEdge%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" style="zoom:20%;" />

<p>  再看一下connect的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Integer headOfChain, StreamEdge edge)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 记录StreamEdge</span></span><br><span class="line">		physicalEdgesInOrder.add(edge);</span><br><span class="line"></span><br><span class="line">		Integer downStreamVertexID = edge.getTargetId();</span><br><span class="line">		<span class="comment">// 这里 headVertex 指的是 headOfChain 对应的 JobVertex（也是当前 node 对应的 vertex）</span></span><br><span class="line">		JobVertex headVertex = jobVertices.get(headOfChain);</span><br><span class="line">		JobVertex downStreamVertex = jobVertices.get(downStreamVertexID);</span><br><span class="line"></span><br><span class="line">		StreamConfig downStreamConfig = <span class="keyword">new</span> StreamConfig(downStreamVertex.getConfiguration());</span><br><span class="line">		<span class="comment">// 这个节点的输入数增加1</span></span><br><span class="line">		downStreamConfig.setNumberOfInputs(downStreamConfig.getNumberOfInputs() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		StreamPartitioner&lt;?&gt; partitioner = edge.getPartitioner();</span><br><span class="line"></span><br><span class="line">		ResultPartitionType resultPartitionType;</span><br><span class="line">		<span class="keyword">switch</span> (edge.getShuffleMode()) &#123;</span><br><span class="line">			<span class="keyword">case</span> PIPELINED:</span><br><span class="line">				resultPartitionType = ResultPartitionType.PIPELINED_BOUNDED;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> BATCH:</span><br><span class="line">				resultPartitionType = ResultPartitionType.BLOCKING;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> UNDEFINED:</span><br><span class="line">				resultPartitionType = determineResultPartitionType(partitioner);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Data exchange mode "</span> +</span><br><span class="line">					edge.getShuffleMode() + <span class="string">" is not supported yet."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 开始创建jobEdge</span></span><br><span class="line">		JobEdge jobEdge;</span><br><span class="line">		<span class="keyword">if</span> (isPointwisePartitioner(partitioner)) &#123;</span><br><span class="line">			jobEdge = downStreamVertex.connectNewDataSetAsInput( <span class="comment">// 这个方法会创建 IntermediateDataSet 对象</span></span><br><span class="line">				headVertex,</span><br><span class="line">				DistributionPattern.POINTWISE, <span class="comment">// 上游与下游的消费模式，（每个生产任务的 sub-task 会连接到消费任务的一个或多个 sub-task）</span></span><br><span class="line">				resultPartitionType);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			jobEdge = downStreamVertex.connectNewDataSetAsInput(</span><br><span class="line">					headVertex,</span><br><span class="line">					DistributionPattern.ALL_TO_ALL, <span class="comment">// 每个生产任务的 sub-task 都会连接到每个消费任务的 sub-task</span></span><br><span class="line">					resultPartitionType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// set strategy name so that web interface can show it.</span></span><br><span class="line">		jobEdge.setShipStrategyName(partitioner.toString());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">			LOG.debug(<span class="string">"CONNECTED: &#123;&#125; - &#123;&#125; -&gt; &#123;&#125;"</span>, partitioner.getClass().getSimpleName(),</span><br><span class="line">					headOfChain, downStreamVertexID);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>执行完<code>connect()</code>方法之后，JobGraph基本已经创建完成。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://izualzhy.cn/flink-source-job-graph" target="_blank" rel="noopener">浅谈 Flink - JobGraph</a></li>
<li><a href="http://matt33.com/2019/12/09/flink-job-graph-3/" target="_blank" rel="noopener">Flink Streaming 作业如何转化为 JobGraph</a></li>
<li><a href="https://blog.jrwang.me/2019/flink-source-code-jobgraph/#jobvertex" target="_blank" rel="noopener">Flink 源码阅读笔记（2）- JobGraph 的生成</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/zh/internals/job_scheduling.html" target="_blank" rel="noopener">Flink作业调度</a></li>
<li><a href="https://developer.aliyun.com/article/725928" target="_blank" rel="noopener">Apache Flink 进阶（六）：Flink 作业执行深度解析</a></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Willi
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://thisiswilli.cn/2020/07/25/flink%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BJobGraph%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/" title="flink源码阅读之JobGraph的生成过程">https://thisiswilli.cn/2020/07/25/flink源码阅读之JobGraph的生成过程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

      <div>
      
        
      
      </div>

      <div>
        
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">
            -------------本文结束
            <i class="fa fa-paw"></i>
            感谢您的阅读-------------
        </div>
    
</div>

        
      </div>
      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/24/flink%E7%94%9F%E6%88%90StreamGraph%E7%9A%84%E8%BF%87%E7%A8%8B/" rel="prev" title="flink生成StreamGraph的过程">
      <i class="fa fa-chevron-left"></i> flink生成StreamGraph的过程
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#flink源码阅读之JobGraph的生成过程"><span class="nav-number">1.</span> <span class="nav-text">flink源码阅读之JobGraph的生成过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#生成JobGraph的整体流程"><span class="nav-number">1.1.</span> <span class="nav-text">生成JobGraph的整体流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从StreamGraph到JobGraph的转化步骤"><span class="nav-number">1.1.1.</span> <span class="nav-text">从StreamGraph到JobGraph的转化步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为每个operator生成hash值"><span class="nav-number">1.1.2.</span> <span class="nav-text">为每个operator生成hash值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setChaining-—判断算子能否chain在一起"><span class="nav-number">1.1.3.</span> <span class="nav-text">setChaining() —判断算子能否chain在一起</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两个StreamNode能否chain"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">判断两个StreamNode能否chain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createJobVertex-创建JobVertex"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">createJobVertex()创建JobVertex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#connect-将JobVertex与JobEdge连接在一起"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">connect()-将JobVertex与JobEdge连接在一起</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reference"><span class="nav-number">1.2.</span> <span class="nav-text">reference</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Willi"
      src="/images/xiaolang.jpeg">
  <p class="site-author-name" itemprop="name">Willi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ThisisWilli" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ThisisWilli" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:295258774@qq.com" title="E-Mail → mailto:295258774@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/wever42/" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;wever42&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/Jerseywwwwei" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;Jerseywwwwei" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Willi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">155k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:21</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      &nbsp;本站访客数&nbsp;<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人</span>	
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      &nbsp;本站总访问量&nbsp;<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span>	
    </span>
  
</div>









      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'WpktFBGS1tJFUonSWplyupKR-gzGzoHsz',
      appKey     : '0AnoRoyQ9ljCCexp2J2QmvBn',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  <div class="bg_content">
  <canvas id="canvas"></canvas>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>