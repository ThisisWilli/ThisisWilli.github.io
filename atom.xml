<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ThisisWilli</title>
  
  <subtitle>Time is now</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thisiswilli.cn/"/>
  <updated>2020-06-16T13:57:47.562Z</updated>
  <id>https://thisiswilli.cn/</id>
  
  <author>
    <name>Willi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kafka架构概述</title>
    <link href="https://thisiswilli.cn/2020/06/16/kafka%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://thisiswilli.cn/2020/06/16/kafka%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</id>
    <published>2020-06-16T13:53:15.000Z</published>
    <updated>2020-06-16T13:57:47.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kafka架构概述"><a href="#kafka架构概述" class="headerlink" title="kafka架构概述"></a>kafka架构概述</h1><p>本文简要介绍kafka架构的基本组成部分</p><a id="more"></a><h2 id="主题层"><a href="#主题层" class="headerlink" title="主题层"></a>主题层</h2><p>Topic、Partition、Replica是kafka存储、消费、生产数据的重要组成部分</p><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>​        在Kafka中，<strong>发布订阅的对象是主题Topic</strong>，你可以为每一类数据创建一个Topic，类似于数据库中的表，或者文件系统中的一个文件目录。</p><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p><img src="https://kafka.apache.org/25/images/log_anatomy.png" alt=""></p><h4 id="为什么要将Topic分为多个partition"><a href="#为什么要将Topic分为多个partition" class="headerlink" title="为什么要将Topic分为多个partition"></a>为什么要将Topic分为多个partition</h4><ul><li>实现数据冗余，容错是分布式系统需要考虑的主要因素之一，可以将每份数据的副本放置到同一topic的不同分区下，避免数据丢失</li><li>解决伸缩性问题，如果一个topic只有一个partition，那么当数据量很大时，积累了太多数据，以致整个节点都无法容纳，那么就需要将topic划分为不同的partition并放置在不同的节点上。</li><li>提高吞吐量，kafka只允许单个consumer对单个partition进行消费，因此，在consumer端，consumer的消费并行度完全依赖于topic中partition的数量，通常情况下，一个kafka集群中partition数量越多，意味着吞吐量的上限越高</li></ul><h4 id="partition的结构"><a href="#partition的结构" class="headerlink" title="partition的结构"></a>partition的结构</h4><ul><li><p>查看kafka集群中每个topic的详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 bin]# .&#x2F;kafka-topics.sh --zookeeper node02:2181,node03:2181,node04:2181 --describe</span><br></pre></td></tr></table></figure><p>输出如下</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Kafka/%E6%9F%A5%E7%9C%8Bkafka%E9%9B%86%E7%BE%A4%E4%B8%ADtopic%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt=""></p></li><li><p>server.properties中配置了kafka日志文件的地址，根据这个地址，查看每个topic在log中的信息</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Kafka/%E6%9F%A5%E7%9C%8Bkafka%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF.png" alt=""></p></li><li><p>查看文件夹中的信息，可以看到其中包含数据的日志文件以及索引文件</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Kafka/%E6%9F%A5%E7%9C%8Bkafka%E9%9B%86%E7%BE%A4%E4%B8%ADtopic%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt=""></p></li><li><p>下图表示一个consumer是如何根据offset在log文件中查找消息的</p><p><img src="https://img-blog.csdn.net/20150121164203539" alt=""></p></li></ul><h4 id="partition的顺序性"><a href="#partition的顺序性" class="headerlink" title="partition的顺序性"></a>partition的顺序性</h4><p>如上图所示，每个partition内部保证消息的顺序，<strong>但是分区之间是不保证顺序的</strong></p><h3 id="Replica"><a href="#Replica" class="headerlink" title="Replica"></a>Replica</h3><ul><li>每个partition可以配置多个副本，kafka定义了两类副本：领导者副本和跟随着副本</li><li>但是只有1个replica可以对外提供服务，与客户端程序进行交互，producer都是往leader replica中写入消息consumer也都是从leader replica中写入消息</li><li>follow replica不能对外界提供服务，只是请求leader replica将最新的消息发送给他，保持与leader replica的消息同步</li></ul><h2 id="消息层"><a href="#消息层" class="headerlink" title="消息层"></a>消息层</h2><h3 id="消息key"><a href="#消息key" class="headerlink" title="消息key"></a>消息key</h3><p>​        发送消息时指定key，这个key也是一个字符数组。key用来确定消息具体写入哪一个分区，kafka的java api中send方法源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">        ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors == <span class="keyword">null</span> ? record : <span class="keyword">this</span>.interceptors.onSend(record);</span><br><span class="line">        <span class="keyword">return</span> doSend(interceptedRecord, callback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ProducerRecord的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a record with a specified timestamp to be sent to a specified topic and partition</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic The topic the record will be appended to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> partition The partition to which the record should be sent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp The timestamp of the record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key The key that will be included in the record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value The record contents</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers the headers that will be included in the record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic, Integer partition, Long timestamp, K key, V value, Iterable&lt;Header&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topic == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Topic cannot be null."</span>);</span><br><span class="line">        <span class="keyword">if</span> (timestamp != <span class="keyword">null</span> &amp;&amp; timestamp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    String.format(<span class="string">"Invalid timestamp: %d. Timestamp should always be non-negative or null."</span>, timestamp));</span><br><span class="line">        <span class="keyword">if</span> (partition != <span class="keyword">null</span> &amp;&amp; partition &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    String.format(<span class="string">"Invalid partition: %d. Partition number should always be non-negative or null."</span>, partition));</span><br><span class="line">        <span class="keyword">this</span>.topic = topic;</span><br><span class="line">        <span class="keyword">this</span>.partition = partition;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">        <span class="keyword">this</span>.headers = <span class="keyword">new</span> RecordHeaders(headers);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果发送消息时注明了key，以及partition的值</p><p>按key进行哈希，相同的key去一个partition，但是如果扩展了partition的数量就不能保证了</p></li><li><p>如果在发送消息时没有填key</p><p>按照round-robin来选partition，这些要发往同一个partition的请求按照配置，攒一波，然后有一个线程单独一次性发过去</p></li></ul><h3 id="生产信息的批量写入"><a href="#生产信息的批量写入" class="headerlink" title="生产信息的批量写入"></a>生产信息的批量写入</h3><p>​        如果每来一条消息就写入kafka，频繁的网络传输会降低kafka的性能，如果将消息以batch的方式写入，把消息收集到一起再同时处理就会高效很多，可以在server.properties中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># The number of messages to accept before forcing a flush of data to disk</span><br><span class="line"># 当达到下面的消息数量时，会将数据flush到日志文件中。默认10000</span><br><span class="line">#log.flush.interval.messages&#x3D;10000</span><br><span class="line"></span><br><span class="line"># The maximum amount of time a message can sit in a log before we force a flush</span><br><span class="line"># 每隔1s，刷新数据到磁盘</span><br><span class="line">#log.flush.interval.ms&#x3D;1000</span><br></pre></td></tr></table></figure><h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><p>​        生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。分区位移总是从 0 开始，假设一个生产者向一个空分区写入了 10 条消息，那么这 10 条消息的位移依次是 0、1、2、…、9。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><ul><li>Kafka的服务端由称为Broker的服务进程构成，即一个kafka集群可以由多个和Broker组成，一个server上可以运行多个kafka broker进程，Kafka支持水平扩展，每个broker在集群中都有一个唯一的broker id，不得重复。</li><li>一般会将不同的Broker分散在不同的节点上，这样如果集群中某一台机器宕机，kafka可以自动选举出其他机器上的Broker继续对外提供服务。</li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li><p>一个kafka节点中可能包含多个Broker进程，其中有且仅有一个Broker会被选举为控制器，即Kafka Controller，controller负责管理整个集群中所有分区和副本的状态</p></li><li><p>当某个partition的leader副本出现故障时，由controller负责通知所有broker更新其元数据信息，当为某个topic增加分区数量时，同样还是由controller负责分区的重新分配</p></li><li><p>在zookeeper中可查看当前集群中，哪个broker为controller</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Kafka/%E5%9C%A8zookeeper%E4%B8%AD%E6%9F%A5%E7%9C%8BController.png" alt=""></p></li></ul><h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RvJJRJNdnQadCGWhzxE6qFRxeaPE5kvlkzq91ZQhp6Tic2x6m4YO1dKMfTfZgLJsV2fCJ4KicAYICVA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" style="zoom:75%;" /><ul><li>生产者可以通过kafka安装包中的kafka-console-producer.sh在teminal下创建，也可以通过相关API进行创建。</li><li>生产者分为Sync Producer 和 Aync Producer<ul><li>Sync Producer同步的生产者，即一定要某条消息成功才会发送下一条(<strong>涉及到kafka的ack机制</strong>)。所以它是低吞吐率、一般不会出现数据丢失。</li><li>Aync Producer异步的生产者，有个队列的概念，是直接发送到队列里面，批量发送。高吞吐率、可能有数据丢失的。</li></ul></li></ul><h3 id="消费者和消费者组"><a href="#消费者和消费者组" class="headerlink" title="消费者和消费者组"></a>消费者和消费者组</h3><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>​        consumer负责消费kafka中的数据，消费者可以通过通过kafka安装包中的kafka-console-consumer.sh在teminal下创建，也可以通过相关API进行创建。</p><h3 id="消费位移"><a href="#消费位移" class="headerlink" title="消费位移"></a>消费位移</h3><p>​        消费者需要记录消费进度，即消费到了哪个分区的哪个位置上，这是消费者位移（<strong>Consumer Offset</strong>）。Consumer offset在kafka中以topic的形式存储，注意，这和上面所说的消息在分区上的位移完全不是一个概念。上面的“位移”表征的是分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就是固定的了。而消费者位移则不同，它可能是随时变化的，毕竟它是消费者消费进度的指示器嘛。通过存储最后消费的 Offset，消费者应用在重启或者停止之后，还可以继续从之前的位置读取。保存的机制可以是 <strong>zookeeper,或者 kafka 自己。</strong></p><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p><img src="https://kafka.apache.org/25/images/consumer-groups.png" alt=""></p><ul><li>消费者组，指的是多个消费者实例组成一个消费者组来消费<strong>一组topic</strong>，一个partition只能被消费者组中的其中一个消费者去消费，<strong>组员之间不能重复消费</strong></li><li><strong>消费者组的引入能够提高消费端的吞吐量</strong>，多个消费者同时消费，能够提高TPS。</li><li>消费者组之间可以互相协助，如果消费者组中有一个消费者挂掉了，kafka能够自动检测到，然后把这个Failed实例之前负责的分区转移给其他活着的消费者，<strong>这个过程称为rebalance</strong></li></ul><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>​        kafka主要使用zookeeper来存储kafka集群的元数据，比如brokers信息，分区的位置和主题的配置等数据都存在zookeeper集群中。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://mp.weixin.qq.com/s/WY1ALBKbW3m9DPM0KnBYxg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WY1ALBKbW3m9DPM0KnBYxg</a></li><li><a href="https://www.cnblogs.com/the-tops/p/6438997.html" target="_blank" rel="noopener">https://www.cnblogs.com/the-tops/p/6438997.html</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650718761&amp;idx=2&amp;sn=6f81fca9439d99e2107058761a05a5d9&amp;chksm=887ddf5fbf0a5649915f0abe483c70633aed63172964aba35ae9d691a567b6578b7949b4e5df&amp;mpshare=1&amp;scene=24&amp;srcid=11160kSpfNskou0uvCcKeFWu&amp;sharer_sharetime=1573864380580&amp;sharer_shareid=15b295e551ad5c3f8c1d45edb42156d2#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650718761&amp;idx=2&amp;sn=6f81fca9439d99e2107058761a05a5d9&amp;chksm=887ddf5fbf0a5649915f0abe483c70633aed63172964aba35ae9d691a567b6578b7949b4e5df&amp;mpshare=1&amp;scene=24&amp;srcid=11160kSpfNskou0uvCcKeFWu&amp;sharer_sharetime=1573864380580&amp;sharer_shareid=15b295e551ad5c3f8c1d45edb42156d2#rd</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kafka架构概述&quot;&gt;&lt;a href=&quot;#kafka架构概述&quot; class=&quot;headerlink&quot; title=&quot;kafka架构概述&quot;&gt;&lt;/a&gt;kafka架构概述&lt;/h1&gt;&lt;p&gt;本文简要介绍kafka架构的基本组成部分&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="https://thisiswilli.cn/categories/Kafka/"/>
    
    
      <category term="big data" scheme="https://thisiswilli.cn/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>idea中配置Lombok + Logback + Slf4j打印日志(附所有踩坑记录)</title>
    <link href="https://thisiswilli.cn/2020/04/30/idea%E4%B8%AD%E9%85%8D%E7%BD%AELombok-Logback-Slf4j%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97-%E9%99%84%E6%89%80%E6%9C%89%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://thisiswilli.cn/2020/04/30/idea%E4%B8%AD%E9%85%8D%E7%BD%AELombok-Logback-Slf4j%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97-%E9%99%84%E6%89%80%E6%9C%89%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2020-04-30T14:56:15.000Z</published>
    <updated>2020-05-01T00:51:14.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="idea中配置Lombok-Logback-Slf4j打印日志-附所有踩坑记录"><a href="#idea中配置Lombok-Logback-Slf4j打印日志-附所有踩坑记录" class="headerlink" title="idea中配置Lombok + Logback + Slf4j打印日志(附所有踩坑记录)"></a>idea中配置Lombok + Logback + Slf4j打印日志(附所有踩坑记录)</h1><p>本文介绍非spring项目中利用Lombok + Logback + Slf4j记录日志，并附上所有的踩坑记录</p><a id="more"></a><p>本文环境</p><ul><li>macos</li><li>Idea2019.2</li></ul><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><ul><li><p>首先在idea中下载lombok插件</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/lombok%E6%8F%92%E4%BB%B6%E5%9B%BE.png" alt=""></p></li><li><p>在pom.xml文件中引入Lombok，Logback，Slf4j依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在项目中的resources文件夹中添加logback,xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span> <span class="attr">value</span>=<span class="string">"/logs"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %boldMagenta(%-5level %logger&#123;50&#125;) : %msg%n&lt;/pattern&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss:SS&#125; %green([%thread]) %highlight(%-5level) %boldMagenta(%logger&#123;50&#125;) - %cyan(%msg%n)<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按照每天生成日志文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件输出的文件名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/provider.log.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件最大的大小--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写代码测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"输出DEBUG级别日志"</span>);</span><br><span class="line">        log.info(<span class="string">"输出INFO级别日志"</span>);</span><br><span class="line">        log.warn(<span class="string">"输出WARN级别日志"</span>);</span><br><span class="line">        log.error(<span class="string">"输出ERROR级别日志"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E8%BE%93%E5%87%BA%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97.png" alt=""></p></li></ul><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>看上去简简单单几步就完成了，然后并不是，接下来附上踩过的坑以及解决方法</p><h3 id="idea中plugins的marketplace直接打不开"><a href="#idea中plugins的marketplace直接打不开" class="headerlink" title="idea中plugins的marketplace直接打不开"></a>idea中plugins的marketplace直接打不开</h3><p>​        在idea中使用lombok需要在plugins中的marketplace中下载插件，然而我下载时marketplace迟迟无法连接上</p><p>​        我们需要在设置中的Appearance &amp; Behavior –&gt;  System Settings –&gt; Http Proxy中选择Auto-detect proxy settings勾选Automatic proxy configuration URL选项并填写url为<a href="http://127.0.0.1:1080" target="_blank" rel="noopener">http://127.0.0.1:1080</a></p><p>重启idea</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E8%A7%A3%E5%86%B3marketplace%E6%89%93%E4%B8%8D%E5%BC%80.png" alt=""></p><h3 id="代码运行成功，但是不显示日志信息"><a href="#代码运行成功，但是不显示日志信息" class="headerlink" title="代码运行成功，但是不显示日志信息"></a>代码运行成功，但是不显示日志信息</h3><p>​        也是很邪门的一种情况，代码没错，但是不显示log打印的信息。</p><p>​        解决方案为，在Build,Execution,Deployment–&gt;compiler–&gt;Annotation Processors中勾选Enable annotation processing，重启idea。</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E5%BC%80%E5%90%AF%E6%B3%A8%E8%A7%A3.png" alt=""></p><h2 id="多个Slf4j冲突"><a href="#多个Slf4j冲突" class="headerlink" title="多个Slf4j冲突"></a>多个Slf4j冲突</h2><p>报错信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SLF4J Warning: Class Path Contains Multiple SLF4J Bindings</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>​        说明是jar包冲突了，maven仓库中可能同时包含了log4j，logback，然后slf4j在程序运行时，不知道binding哪一个jar包。</p><p>解决方案为：在maven仓库中删除其中一个jar包，只保留一个</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;idea中配置Lombok-Logback-Slf4j打印日志-附所有踩坑记录&quot;&gt;&lt;a href=&quot;#idea中配置Lombok-Logback-Slf4j打印日志-附所有踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;idea中配置Lombok + Logback + Slf4j打印日志(附所有踩坑记录)&quot;&gt;&lt;/a&gt;idea中配置Lombok + Logback + Slf4j打印日志(附所有踩坑记录)&lt;/h1&gt;&lt;p&gt;本文介绍非spring项目中利用Lombok + Logback + Slf4j记录日志，并附上所有的踩坑记录&lt;/p&gt;
    
    </summary>
    
    
      <category term="环境搭建" scheme="https://thisiswilli.cn/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper简介及JavaAPI简单操作</title>
    <link href="https://thisiswilli.cn/2020/04/27/Zookeeper%E7%AE%80%E4%BB%8B%E5%8F%8AJavaAPI%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
    <id>https://thisiswilli.cn/2020/04/27/Zookeeper%E7%AE%80%E4%BB%8B%E5%8F%8AJavaAPI%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-27T06:14:10.000Z</published>
    <updated>2020-04-27T06:17:07.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper简介及利用JavaAPI操作"><a href="#Zookeeper简介及利用JavaAPI操作" class="headerlink" title="Zookeeper简介及利用JavaAPI操作"></a>Zookeeper简介及利用JavaAPI操作</h1><p>本文介绍zookeeper的伪分布式安装，zookeeper中的基本概念以及利用JavaAPI简单操作zookeeper</p><a id="more"></a><h2 id="zookeeper安装"><a href="#zookeeper安装" class="headerlink" title="zookeeper安装"></a>zookeeper安装</h2><p>Zookeeper主要有以下部署模式</p><ul><li>Standalone模式：单机部署，用于验证zookeeper的功能</li><li>伪集群模式：类似于kafka的单机多broker模式，用java进程模拟一个zookeeper服务，也是单机部署</li><li>集群模式：在多台服务其中部署</li></ul><p>因为没有服务器资源，本文介绍伪集群模式部署，具体步骤如下，本机环境为macos10.15.4</p><ol><li><p>下载zookeeper，可以选择<a href="http://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">官网下载</a>，也可以下载<a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">cdh版本</a></p></li><li><p>下载到本地之后解压</p><ul><li><p>配置环境变量<code>➜  ~ vim .bash_profile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ZOOKEEPER_HOME&#x3D;your path</span><br><span class="line">export PATH&#x3D;$PATH:$ZOOKEEPER_HOME&#x2F;bin</span><br></pre></td></tr></table></figure></li><li><p>使更改生效<code>➜  ~ source .bash_profile</code></p></li></ul></li><li><p>切换到zookeeper下的conf目录，创建三个配置文件zoo1.cfg，zoo1.cfg，zoo1.cfg</p><p>zookeeper中有三个重要端口</p><ul><li>2181：对cline端提供服务</li><li>3888：选举leader使用</li><li>2888：集群内机器通讯使用（Leader监听此端口）</li></ul><p>本文介绍伪分布式安装，所有这三个端口也应该使用不同的端口号，三个配置文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">zoo1.cfg</span><br><span class="line"># 用于zk节点之间的心跳检测，最小session超时时间是ticktime的两倍</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># Leader服务器等待Follower启动并完成数据同步的时间，默认值10，表示tickTime的10倍</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># Leader服务器和Follower之间进行心跳检测的最大延时时间，默认值5，表示tickTime的5倍</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># Zookeeper服务器存储快照文件的目录，必须配置</span><br><span class="line">dataDir&#x3D;&#x2F;BigDataComponent&#x2F;zookeeper&#x2F;data_1</span><br><span class="line"># Zookeeper服务器存储事务日志的目录，默认为dataDir</span><br><span class="line">dataLogDir&#x3D;&#x2F;BigDataComponent&#x2F;zookeeper&#x2F;log_1</span><br><span class="line"># 监听客户端连接的端口</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line">server.1 &#x3D; localhost:2888:3888</span><br><span class="line">server.2 &#x3D; localhost:2889:3889</span><br><span class="line">server.3 &#x3D; localhost:2890:3890</span><br><span class="line"></span><br><span class="line">zoo2.cfg</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line">dataDir&#x3D;&#x2F;BigDataComponent&#x2F;zookeeper&#x2F;data_2</span><br><span class="line">dataLogDir&#x3D;&#x2F;BigDataComponent&#x2F;zookeeper&#x2F;log_2</span><br><span class="line">clientPort&#x3D;2182</span><br><span class="line">server.1 &#x3D; localhost:2888:3888</span><br><span class="line">server.2 &#x3D; localhost:2889:3889</span><br><span class="line">server.3 &#x3D; localhost:2890:3890</span><br><span class="line"></span><br><span class="line">zoo3.cfg</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line">dataDir&#x3D;&#x2F;BigDataComponent&#x2F;zookeeper&#x2F;data_3</span><br><span class="line">dataLogDir&#x3D;&#x2F;BigDataComponent&#x2F;zookeeper&#x2F;log_3</span><br><span class="line">clientPort&#x3D;2183</span><br><span class="line">server.1 &#x3D; localhost:2888:3888</span><br><span class="line">server.2 &#x3D; localhost:2889:3889</span><br><span class="line">server.3 &#x3D; localhost:2890:3890</span><br></pre></td></tr></table></figure></li><li><p><strong>在启动之前，还有重要一步</strong>，在三个dataDir文件下创建一个myid文件，分别写入1，2，3对应配置文件中的server.1，server.2，server.3</p></li><li><p>启动zk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  conf zkServer.sh start $ZOOKEEPER_HOME&#x2F;conf&#x2F;zoo1.cfg</span><br><span class="line">➜  conf zkServer.sh start $ZOOKEEPER_HOME&#x2F;conf&#x2F;zoo2.cfg</span><br><span class="line">➜  conf zkServer.sh start $ZOOKEEPER_HOME&#x2F;conf&#x2F;zoo3.cfg</span><br></pre></td></tr></table></figure></li><li><p>查看jps进程以及每个zookeeper进程的状态，可以看到主从状态，说明安装成功。</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E6%9F%A5%E7%9C%8Bzookeeper%E7%8A%B6%E6%80%81.png" alt=""></p></li></ol><h2 id="zookeeper的数据模型"><a href="#zookeeper的数据模型" class="headerlink" title="zookeeper的数据模型"></a>zookeeper的数据模型</h2><p>​        zookeeper具有分层的名称空间，类似于分布式文件系统。</p><p><img src="https://zookeeper.apache.org/doc/r3.1.2/images/zknamespace.jpg" alt=""></p><h3 id="ZNodes"><a href="#ZNodes" class="headerlink" title="ZNodes"></a>ZNodes</h3><p>​        如上图所示，每个节点都被当作一个znode，每个znode中都维护着一个stat structure和一个时间戳，状态结构包含着节点数据以及acl的版本变更信息，stat structure结合时间戳能够让zookeeper验证数据缓存以及及时更新数据，每当znode中的数据发生改变，版本号就会相应增加， 并且，当客户端执行更新或删除时，它必须提供其更改的znode数据的版本。 如果它提供的版本与数据的实际版本不匹配，则更新将失败。</p><h4 id="Watches"><a href="#Watches" class="headerlink" title="Watches"></a>Watches</h4><p>​       ZooKeeper中的所有读取操作<code>getData()，getChildren()和exist()</code>都可以附属一次watch操作。ZooKeeper对watch的定义为：watch事件<strong>是一次性触发的</strong>，发送给设置watch的客户端，该事件在设置watch的数据更改时发生。 在watch的定义中，需要考虑三个关键点</p><ul><li><strong>一次性触发</strong>：数据更改后，一个watch事件将发送给客户端。 例如，如果客户端执行<code>getData(&quot;/ znode1&quot;,true)</code>，然后/ znode1的数据被更改或删除，则服务端会向客户端返回/ znode1的watch事件。 如果/ znode1再次更改，则除非客户端进行了另一次读取以设置新的watch，否则不会发送任何watch事件。</li><li><strong>watch发送至客户端</strong>：Watch事件是异步发送到客户端。Zookeeper可以保证客户端发送过去的更新顺序是有序的。例如：某个Znode没有设置watcher，那么客户端对这个Znode设置Watcher发送到集群之前，该客户端是感知不到该Znode任何的改变情况的。换个角度来解释：由于Watch有一次性触发的特点，所以在服务器端没有Watcher的情况下，Znode的任何变更就不会通知到客户端。不过，即使某个Znode设置了Watcher，且在Znode有变化的情况下通知到了客户端，但是在客户端接收到这个变化事件，但是还没有再次设置Watcher之前，如果其他客户端对该Znode做了修改，这种情况下，Znode第二次的变化客户端是无法收到通知的。这可能是由于网络延迟或者是其他因素导致，所以我们使用Zookeeper不能期望能够监控到节点每次的变化。<strong>Zookeeper只能保证最终的一致性，而无法保证强一致性。</strong></li><li><strong>设置watch的数据内容</strong>：Znode改变有很多种方式，例如：节点创建，节点删除，节点改变，子节点改变等等。Zookeeper维护了两个Watch列表，一个节点数据Watch列表，另一个是子节点Watch列表。<code>getData()和exists()</code>设置数据Watch，<code>getChildren()</code>设置子节点Watch。两者选其一，可以让我们根据watch的返回结果选择不同的Watch方式，<code>getData()和exists()</code>返回节点的内容，getChildren()返回子节点列表。因此，<code>setData()</code>触发内容Watch，<code>create()</code>触发当前节点的内容Watch或者是其父节点的子节点Watch。<code>delete()</code>同时触发父节点的子节点Watch和内容Watch，以及子节点的内容Watch</li></ul><p>​        Watch在客户端连接到的ZooKeeper服务器上本地维护。 这使watch更加轻量，更容易维护和调度。 当客户端连接到新服务器时，watch将会被任何session事件触发。 当客户端与服务器断开连接时，client不会收到任何watch。 当客户端重新连接时，任何以前注册的watch将被重新注册并在需要时触发。 通常，所有这些都是透明发生的。 在某些情况下，可能会丢失监视：如果在断开连接的情况下创建并删除了znode，则会丢失尚未创建的znode的监视。</p><p>Watch中分为事件类型和状态类型，事件类型于znode节点相关，状态类型于连接的客户端相关，具体如下</p><table><thead><tr><th>KeeperState</th><th>EventType</th><th>触发条件</th></tr></thead><tbody><tr><td></td><td>None(-1)</td><td>客户端于服务端成功创建连接</td></tr><tr><td>SyncConnected(3)</td><td>NodeCreated(1)</td><td>Watcher监听的对应数据节点被创建</td></tr><tr><td></td><td>NodeDelected(2)</td><td>Watcher监听的对应数据节点被删除</td></tr><tr><td></td><td>NodeDataChanged(3)</td><td>Watcher监听的对应数据节点的数据内容发生变化</td></tr><tr><td></td><td>NodeChildChanged(4)</td><td>Watcher监听的对应数据节点的子节点发生变化</td></tr><tr><td>Disconnected(0)</td><td>None(-1)</td><td>客户端于Zookeeper服务器断开连接</td></tr><tr><td>Expired(-112)</td><td>None(-1)</td><td>会话超时</td></tr><tr><td>AuthFailed(4)</td><td>None(-1)</td><td>权限不足</td></tr></tbody></table><h4 id="Data-Access"><a href="#Data-Access" class="headerlink" title="Data Access"></a>Data Access</h4><p>​        znode上的数据的读写都是原子的，在读取时将会获取与znode关联的所有数据，而在写入时则会替换所有数据，在每个znode中都有一个访问控制列表(access control list)，用于控制访问权限。</p><h3 id="Zookeeper-Stat-Structure"><a href="#Zookeeper-Stat-Structure" class="headerlink" title="Zookeeper Stat Structure"></a>Zookeeper Stat Structure</h3><p>zookeeper中每个znode都会维护一个stat其中每个参数的含义如下</p><ul><li>czxid：引起这个znode创建的zxid，创建节点的事务的zxid</li><li>ctime： znode被创建的毫秒数(从1970年开始)</li><li>mzxid： znode最后更新的zxid</li><li>mtime：znode最后修改的毫秒数(从1970年开始)</li><li>pZxid：znode最后更新的子节点zxid</li><li>cversion ：znode子节点变化号，znode子节点修改次数</li><li>dataversion： znode数据变化号</li><li>aclVersion：znode访问控制列表的变化号</li><li>ephemeralOwner：如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0</li><li>dataLength：znode的数据长度</li><li>numChildren：znode子节点数量</li></ul><h2 id="Zookeeper-Session"><a href="#Zookeeper-Session" class="headerlink" title="Zookeeper Session"></a>Zookeeper Session</h2><p>​        ZooKeeper客户端通过使用语言绑定创建服务的句柄来与ZooKeeper服务建立会话。 创建句柄之后，该句柄将开始处于CONNECTING状态，并且客户端库尝试连接到组成ZooKeeper服务的服务器之一，然后将其切换为CONNECTED状态。 在正常操作期间，客户端句柄将处于这两种状态之一。 如果发生不可恢复的错误，例如会话到期或身份验证失败，或者如果应用程序显式关闭了句柄，则该句柄将移至CLOSED状态。 下图显示了ZooKeeper客户端可能的状态转换。</p><p><img src="https://zookeeper.apache.org/doc/current/images/state_dia.jpg" alt=""></p><h2 id="Zookeeper简单操作"><a href="#Zookeeper简单操作" class="headerlink" title="Zookeeper简单操作"></a>Zookeeper简单操作</h2><p>使用zookeeper JavaAPI时首先要在pom中导入zookeeper依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>创建一个永久znode节点，并打印其中的Zookeeper Stat Structure和数据信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/test_zookeeper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyWatch</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"====已经触发了 "</span> + watchedEvent.getType() + <span class="string">" 类型的事件===="</span>);</span><br><span class="line">                System.out.println(<span class="string">"====节点中的路径为："</span> + watchedEvent.getPath() + <span class="string">"===="</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MyWatch watch = <span class="keyword">new</span> MyWatch();</span><br><span class="line"><span class="comment">//        MyWatch watch = new MyWatch().getInstance();</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:2181,localhost:2182,localhost:2183"</span>, <span class="number">3000</span>, watch);</span><br><span class="line">            <span class="keyword">if</span> (zk.exists(PATH, <span class="keyword">true</span>) != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                Stat stat = zk.exists(PATH, <span class="keyword">true</span>);</span><br><span class="line">                System.out.println(<span class="string">"stat中的6个属性为"</span>);</span><br><span class="line">                System.out.println(stat.toString());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] data = zk.getData(PATH, <span class="keyword">null</span>, zk.exists(PATH, <span class="keyword">true</span>));</span><br><span class="line">                System.out.println(PATH + <span class="string">"中的数据为"</span> + <span class="keyword">new</span> String(data));</span><br><span class="line"></span><br><span class="line">                zk.setData(PATH,  <span class="string">"修改数据"</span>.getBytes(), stat.getVersion());</span><br><span class="line">                data = zk.getData(PATH, <span class="keyword">null</span>, zk.exists(PATH, <span class="keyword">true</span>));</span><br><span class="line">                System.out.println(PATH + <span class="string">"修改后的数据为: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line">                zk.setData(PATH,  <span class="string">"再次修改数据"</span>.getBytes(), zk.exists(PATH, <span class="keyword">true</span>).getVersion());</span><br><span class="line">                data = zk.getData(PATH, <span class="keyword">null</span>, zk.exists(PATH, <span class="keyword">true</span>));</span><br><span class="line">                System.out.println(PATH + <span class="string">"再次修改后的数据为: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">//                zk.delete(PATH, zk.exists(PATH, true).getVersion());</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                zk.create(PATH, (PATH + <span class="string">"中的数据"</span>).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | KeeperException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">已经触发了 None 类型的事件</span><br><span class="line">节点中的路径为：null</span><br><span class="line">已经触发了 NodeCreated 类型的事件</span><br><span class="line">节点中的路径为：&#x2F;test_zookeeper</span><br></pre></td></tr></table></figure><p>在命令行启动zk的客户端，查看zk中的znode，如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E5%9C%A8zk%E4%B8%AD%E6%9F%A5%E7%9C%8Bznode.png" alt=""></p><p>再次运行如上代码，输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;已经触发了 None 类型的事件&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;节点中的路径为：null&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">stat中的6个属性为</span><br><span class="line">8589934647,8589934647,1587956249662,1587956249662,0,0,0,0,27,0,8589934647</span><br><span class="line"></span><br><span class="line">&#x2F;test_zookeeper中的数据为&#x2F;test_zookeeper中的数据</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;已经触发了 NodeDataChanged 类型的事件&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;节点中的路径为：&#x2F;test_zookeeper&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;test_zookeeper修改后的数据为: 修改数据</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;已经触发了 NodeDataChanged 类型的事件&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;节点中的路径为：&#x2F;test_zookeeper&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;test_zookeeper再次修改后的数据为: 再次修改数据</span><br></pre></td></tr></table></figure><p>在命令行中查看znode中的数据和stat structure</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E6%9F%A5%E7%9C%8Bznode%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt=""></p></li><li><p>接下来验证watch的一次性触发机制，根据前文所述，在执行exist方法时就会触发一次watch，如果需要继续监视znode的变化，必须再新建一个watch，exist方法源码如下，我们在执行一次exist，可以选择是否再创建一个初始watch。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(String path, <span class="keyword">boolean</span> watch)</span> <span class="keyword">throws</span> KeeperException,</span></span><br><span class="line"><span class="function">        InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">          <span class="comment">// 如果为true，则在执行exist方法后在创建一个watcher，继续监视</span></span><br><span class="line">    <span class="keyword">return</span> exists(path, watch ? watchManager.defaultWatcher : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> KeeperException, InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String clientPath = path;</span><br><span class="line">        PathUtils.validatePath(clientPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the watch contains the un-chroot path</span></span><br><span class="line">        WatchRegistration wcb = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wcb = <span class="keyword">new</span> ExistsWatchRegistration(watcher, clientPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">        RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">        h.setType(ZooDefs.OpCode.exists);</span><br><span class="line">        ExistsRequest request = <span class="keyword">new</span> ExistsRequest();</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setWatch(watcher != <span class="keyword">null</span>);</span><br><span class="line">        SetDataResponse response = <span class="keyword">new</span> SetDataResponse();</span><br><span class="line">        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.getErr() == KeeperException.Code.NONODE.intValue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                    clientPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response.getStat().getCzxid() == -<span class="number">1</span> ? <span class="keyword">null</span> : response.getStat();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们将代码更改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/test_zookeeper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyWatch</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"====已经触发了 "</span> + watchedEvent.getType() + <span class="string">" 类型的事件===="</span>);</span><br><span class="line">                System.out.println(<span class="string">"====节点中的路径为："</span> + watchedEvent.getPath() + <span class="string">"===="</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MyWatch watch = <span class="keyword">new</span> MyWatch();</span><br><span class="line"><span class="comment">//        MyWatch watch = new MyWatch().getInstance();</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:2181,localhost:2182,localhost:2183"</span>, <span class="number">3000</span>, watch);</span><br><span class="line">            <span class="keyword">if</span> (zk.exists(PATH, <span class="keyword">false</span>) != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                Stat stat = zk.exists(PATH, <span class="keyword">false</span>);</span><br><span class="line">                System.out.println(<span class="string">"stat中的6个属性为"</span>);</span><br><span class="line">                System.out.println(stat.toString());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] data = zk.getData(PATH, <span class="keyword">null</span>, zk.exists(PATH, <span class="keyword">false</span>));</span><br><span class="line">                System.out.println(PATH + <span class="string">"中的数据为"</span> + <span class="keyword">new</span> String(data));</span><br><span class="line"></span><br><span class="line">                zk.setData(PATH,  <span class="string">"修改数据"</span>.getBytes(), stat.getVersion());</span><br><span class="line">                data = zk.getData(PATH, <span class="keyword">null</span>, zk.exists(PATH, <span class="keyword">false</span>));</span><br><span class="line">                System.out.println(PATH + <span class="string">"修改后的数据为: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line">                zk.setData(PATH,  <span class="string">"再次修改数据"</span>.getBytes(), zk.exists(PATH, <span class="keyword">false</span>).getVersion());</span><br><span class="line">                data = zk.getData(PATH, <span class="keyword">null</span>, zk.exists(PATH, <span class="keyword">false</span>));</span><br><span class="line">                System.out.println(PATH + <span class="string">"再次修改后的数据为: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">//                zk.delete(PATH, zk.exists(PATH, true).getVersion());</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                zk.create(PATH, (PATH + <span class="string">"中的数据"</span>).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | KeeperException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，后续的操作没有再触发wathcer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;已经触发了 None 类型的事件&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;节点中的路径为：null&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">stat中的6个属性为</span><br><span class="line">8589934647,8589934655,1587956249662,1587956369218,4,0,0,0,18,0,8589934647</span><br><span class="line"></span><br><span class="line">&#x2F;test_zookeeper中的数据为再次修改数据</span><br><span class="line">&#x2F;test_zookeeper修改后的数据为: 修改数据</span><br><span class="line">&#x2F;test_zookeeper再次修改后的数据为: 再次修改数据</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Zookeeper简介及利用JavaAPI操作&quot;&gt;&lt;a href=&quot;#Zookeeper简介及利用JavaAPI操作&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper简介及利用JavaAPI操作&quot;&gt;&lt;/a&gt;Zookeeper简介及利用JavaAPI操作&lt;/h1&gt;&lt;p&gt;本文介绍zookeeper的伪分布式安装，zookeeper中的基本概念以及利用JavaAPI简单操作zookeeper&lt;/p&gt;
    
    </summary>
    
    
      <category term="Zookeeper" scheme="https://thisiswilli.cn/categories/Zookeeper/"/>
    
    
      <category term="big data" scheme="https://thisiswilli.cn/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="https://thisiswilli.cn/2020/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://thisiswilli.cn/2020/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-21T12:06:53.000Z</published>
    <updated>2020-04-21T12:16:18.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>本文介绍结构性设计模式中的代理模式</p><a id="more"></a><h3 id="代理模式是什么"><a href="#代理模式是什么" class="headerlink" title="代理模式是什么"></a>代理模式是什么</h3><p>​        代理模式属于结构型设计模式，就好比日常生活中，你经常委托别人帮你办一些事情，比如让室友帮忙拿一下快递，或者带一餐饭，又或者是让房租中介帮你去寻找毕业工作所需要的租住的房子。在日常开发中，也会存在这样的场景，我们需要调用一些方法，但我们并不想了解其中详细的原理，只想通过一个中间对象来帮我们处理这些事情，那么就需要使用代理模式。</p><h3 id="代理模式分类及实现"><a href="#代理模式分类及实现" class="headerlink" title="代理模式分类及实现"></a>代理模式分类及实现</h3><p>​        我们以买基金为例，小狼身上有很多闲钱，想要通过投资来钱生钱，但是股市风险较大，并且小狼的金融知识也十分匮乏，所以小狼就通过买股票型基金的方式来投资，购买股票型基金，就是通过让比你更专业，更懂得玩钱的基金经理来帮你购买股票，这种方式就可以抽象为代理模式。</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理中包括以下几个角色：</p><ul><li><p>抽象角色：一般采用接口或者抽象类解决，在这个例子中可以抽象为<strong>买卖基金这些交易行为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transcation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真实角色：需要实现抽象角色接口，并实现具体的业务逻辑，是真正要被代理的具体类，它供代理角色调用，在这个例子中可以理解为<strong>各种基金</strong>，这些基金被专门的基金经理购买</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fund</span> <span class="keyword">implements</span> <span class="title">Transcation</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买基金"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖基金"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理角色：代理真实角色，代理真实角色之后，会做一些附属操作，在这个例子中可以理解为<strong>基金经理</strong>，而基金经理在执行代理操作时，往往会包括一些前续操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FundManager</span> <span class="keyword">implements</span> <span class="title">Transcation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Fund fund;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FundManager</span><span class="params">(Fund fund)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fund = fund;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        searchBuy();</span><br><span class="line">        fund.buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        searchSell();</span><br><span class="line">        fund.sell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchBuy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"寻找潜力高的股票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchSell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"预估哪些股票会跌"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户 ：访问代理角色的人，在这个例子中就是投资市场中的散户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fund fund = <span class="keyword">new</span> Fund();</span><br><span class="line">        FundManager manager = <span class="keyword">new</span> FundManager(fund);</span><br><span class="line">        manager.buy();</span><br><span class="line">        manager.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">寻找潜力高的股票</span><br><span class="line">买基金</span><br><span class="line">预估哪些股票会跌</span><br><span class="line">卖基金</span><br></pre></td></tr></table></figure></li></ul><p>静态代理的优点</p><ul><li>实现了业务的分工，解耦了代码逻辑</li><li><strong>可以在在不改动原有代码上增加新功能</strong></li></ul><p>静态代理的缺点</p><ul><li>一个角色就会产生一个代理，随着需要代理的业务越多，代码量会翻倍</li></ul><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>​        在静态代理的场景下接着思考，如果小狼觉得买股票型基金风险太大，他还是偏向于买稳定的混合型基金，那么股票型基金经理不能完成这种代理，如果还是依照静态代理，那么我们还要定义一个混合型基金的接口，并新建一个混合型基金的代理类，那么随着代码复杂度的增加，就很难维护这么多代理类和被代理类，那么我们就需要动态代理，当我们需要频繁切换代理类形式，动态代理能够通过一个代理类来代理N多个被代理类，动态代理在切换接口时，不需要重新定义代理类，应为动态代理不需要根据接口提前定义代理类，他把代理类的创建推迟到到代码运行时<strong>通过反射来创建</strong></p><ul><li><p>动态代理和静态代理角色一样</p></li><li><p>动态代理的代理类是动态生成的，不是直接写好的，即不同股票的基金经理是在代码执行过程中，通过反射创建</p></li><li><p>动态代理分为两大类：基于接口的动态代理，基于类的动态代理</p><ul><li><p>基于接口–jdk动态代理</p></li><li><p>基于类：cglib</p></li><li><p>java字节码实现：javasist</p><pre><code>静态代理和动态代理的区别为，静态代理在运行之前，JVM会读取代理类的.class文件，而动态代理是在代码运行时才动态生成代理类。</code></pre></li></ul></li></ul><p>动态代理的实现如下</p><ul><li><p>实现混合型基金和股票型基金的操作接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MixTranscation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StackTranscation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现两个基金类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFund</span> <span class="keyword">implements</span> <span class="title">StackTranscation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抛售股票型基金"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"购买股票型基金"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MixFund</span> <span class="keyword">implements</span> <span class="title">MixTranscation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抛售混合型基金"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"购买混合型基金"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个类专门来生成代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyInvocationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 处理代理类并返回result</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 动态代理的本质，就是使用反射机制实现</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义client实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代理角色</span></span><br><span class="line">        <span class="comment">// 代理角色：现在没有</span></span><br><span class="line">        ProxyInvocationHandler pih = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        <span class="comment">// 通过调用程序处理橘色来处理我们要调用的接口对象</span></span><br><span class="line">        <span class="comment">// 动态生成代理</span></span><br><span class="line">        pih.setTarget(<span class="keyword">new</span> StackFund());</span><br><span class="line">        StackTranscation proxy = (StackTranscation)pih.getProxy();</span><br><span class="line">        proxy.buy();</span><br><span class="line">        proxy.sell();</span><br><span class="line"></span><br><span class="line">        pih.setTarget(<span class="keyword">new</span> MixFund());</span><br><span class="line">        MixTranscation mixProxy = (MixTranscation)pih.getProxy();</span><br><span class="line">        mixProxy.buy();</span><br><span class="line">        mixProxy.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">购买股票型基金</span><br><span class="line">抛售股票型基金</span><br><span class="line">购买混合型基金</span><br><span class="line">抛售混合型基金</span><br></pre></td></tr></table></figure></li></ul><p>动态代理的优缺点如下</p><ul><li>能够通过动态代理的方式创建代理角色，减少了代码量，降低了维护难度</li><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会导致处理速度变慢</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;p&gt;本文介绍结构性设计模式中的代理模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://thisiswilli.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://thisiswilli.cn/tags/Java/"/>
    
      <category term="设计模式" scheme="https://thisiswilli.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之自定义一个线程池</title>
    <link href="https://thisiswilli.cn/2020/03/30/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://thisiswilli.cn/2020/03/30/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-03-30T08:13:36.000Z</published>
    <updated>2020-03-30T08:16:21.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义一个线程池"><a href="#自定义一个线程池" class="headerlink" title="自定义一个线程池"></a>自定义一个线程池</h1><p>本文尝试实现一个线程池，具体架构如下所示，有以下几个成员</p><a id="more"></a><ul><li>task：具体需要执行的任务，实现Runnable和Callable接口</li><li>worker：任务的执行者，继承Thread类</li><li>workerSet：worker的集合，有大小限制，因为线程池不能无限扩大，或占用太多资源</li><li>BlockingQueue：阻塞队列，用于存放还没来得及执行的task</li></ul><p>整体架构图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A001.png" alt=""></p><h2 id="实现阻塞队列"><a href="#实现阻塞队列" class="headerlink" title="实现阻塞队列"></a>实现阻塞队列</h2><p>在定义阻塞队列时，<strong>可以参考生产者和消费者模式</strong>，要考虑两种极端情况</p><ul><li>队列为空时，要让想要获取task去执行的Worker即消费者阻塞，</li><li>队列为满时，要让想将task放入BlockQueue的线程即生产者(main线程)阻塞。</li></ul><p>在入队和出队时，也要保证线程安全，具体实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 1.任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signalAll();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T element)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(element);</span><br><span class="line">            emptyWaitSet.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.获取大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞队列优化之poll"><a href="#阻塞队列优化之poll" class="headerlink" title="阻塞队列优化之poll"></a>阻塞队列优化之poll</h3><p>​        当workerSet中的worker完成了自己的task后，会检查BlockingQueue中有没有未完成的task，为了避免Worker无限等待，产生饥饿的情况，让Worker在等待一定时间过后放弃等待，避免Worker永久阻塞，<strong>注意避免虚假唤醒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带超时的阻塞获取，虚假唤醒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 避免虚假唤醒</span></span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signalAll();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞队列优化之offer增强"><a href="#阻塞队列优化之offer增强" class="headerlink" title="阻塞队列优化之offer增强"></a>阻塞队列优化之offer增强</h3><p>​        当所需执行的任务数大于blockQueue的size加上worker的数量时，并且每个任务耗时过长，则可能会出现<strong>主线程死等的情况</strong>，需要对put方法进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task, <span class="keyword">long</span> timeout, TimeUnit timeUnit)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"等待加入任务队列"</span> + task);</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"加入任务队列"</span> + task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signalAll();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadPool实现"><a href="#ThreadPool实现" class="headerlink" title="ThreadPool实现"></a>ThreadPool实现</h2><p>在threadPool中，将Worker定义为内部类，提供execute()方法来执行ThreadPool创建是传进来的任务</p><h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p>​        任务在提交时，如果ThreadPool中没有线程，那么创建线程并执行任务，如果Threadpool中存在线程但是数量不足，就将task放入阻塞队列</p><p>​        先创建一个execute方法，在execute方法中由Worker类去执行任务，当ThreadPool中容量已满时，需要将task放入BlockQueue中，等待空闲的Worker来执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">            <span class="comment">// 任务数没有超过coreSize时，直接交给worker对象执行</span></span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize)&#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果超过则交给bk</span></span><br><span class="line">                taskQueue.put(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">            <span class="comment">// 任务数没有超过coreSize时，直接交给worker对象执行</span></span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize)&#123;</span><br><span class="line">                System.out.println(<span class="string">"新增一个worker: "</span> + workers + <span class="string">" "</span> + task);</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果超过则交给bk</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"将"</span> + task + <span class="string">"加入任务队列："</span> );</span><br><span class="line">                taskQueue.put(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        让Worker类继承Thread类，并重写run方法，在执行完task时，需要检查BlockQueue中是否还有任务，如果有，则拿出来执行，并且Worker是不停执行任务的，并且也可以用定时等待来优化，避免worker在所有task执行完之后，还在尝试从BlockingQueue中拿task来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当task不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 当task执行完毕，在接着看任务队列中是否有任务，有则获取任务并执行</span></span><br><span class="line"><span class="comment">//            while (task != null || (task = taskQueue.take()) != null)&#123;</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行："</span> + task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">                System.out.println(<span class="string">"worker被移除"</span> + <span class="keyword">this</span>);</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>​        在一开始定义ThreadPool时，不管task的数量有多少，我们都让main线程将多余task放入BlockingQueue中，在这种方案下，当worker全在工作，并且task耗时很长，而且BlockQueue中已经堆满了task，那么，main线程就会一直死等，这显然是调用者不愿看到的，所以我们需要将决策抽象成一个接口，让调用者来决定下一步怎么执行，<strong>也就是设计模式中的策略模式</strong>，比如：</p><p>当所需workers个数的大小大于coreSize时</p><ul><li>可以让主线程将task放入BlockQueue中并死等，</li><li>带超时等待</li><li>让调用者放弃任务执行</li><li>让调用者自己执行任务</li></ul><p>具体实现如下</p><ul><li><p>先定义一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在创建ThreadPool时也要实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit, <span class="keyword">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockQueue&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在BlockingQueue类中，当worker个数大于coreSize时，执行一个新创建的方法，执行相应的策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capcity)&#123;</span><br><span class="line">                rejectPolicy.reject(<span class="keyword">this</span>, task);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有空闲</span></span><br><span class="line">                System.out.println(<span class="string">"加入任务队列"</span> + task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signalAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在创建ThreadPool类时，需要将reject的策略传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit, <span class="keyword">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockQueue&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试时，我们模拟两种情况，</p><ul><li><p>一种情况为当BlockingQueue已满时，主线程定时等待，每个worker的任务为打印数字，编写主方法如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, ((queue, task) -&gt; &#123;</span><br><span class="line">             queue.offer(task, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​        我们只定义了2个worker，每个task耗时3s，而最长等待时间为1s，所以肯定有任务worker是来不及执行的，输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">新增一个worker: [] com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@2f4d3709</span><br><span class="line">Thread-0正在执行：com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@2f4d3709</span><br><span class="line">新增一个worker: [Thread[Thread-0,5,main]] com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@1d81eb93</span><br><span class="line">main将com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@34a245ab加入任务队列：</span><br><span class="line">Thread-1正在执行：com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@1d81eb93</span><br><span class="line">加入任务队列com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@34a245ab</span><br><span class="line">main将com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@7cc355be加入任务队列：</span><br><span class="line">等待加入任务队列com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@7cc355be</span><br><span class="line">等待加入任务队列com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@7cc355be</span><br><span class="line">main将com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@12edcd21加入任务队列：</span><br><span class="line">等待加入任务队列com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@12edcd21</span><br><span class="line">等待加入任务队列com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@12edcd21</span><br><span class="line">Thread-1 1</span><br><span class="line">Thread-0 0</span><br><span class="line">Thread-1正在执行：com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@34a245ab</span><br><span class="line">worker被移除Thread[Thread-0,5,main]</span><br><span class="line">Thread-1 2</span><br><span class="line">worker被移除Thread[Thread-1,5,main]</span><br></pre></td></tr></table></figure></li><li><p>第二种情况，当来不及执行时，由主线程创建线程来执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, ((queue, task) -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(task, <span class="string">"救火队员"</span>).start();</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">新增一个worker: [] com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@2f4d3709</span><br><span class="line">Thread-0正在执行：com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@2f4d3709</span><br><span class="line">新增一个worker: [Thread[Thread-0,5,main]] com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@1d81eb93</span><br><span class="line">Thread-1正在执行：com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@1d81eb93</span><br><span class="line">main将com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@34a245ab加入任务队列：</span><br><span class="line">加入任务队列com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@34a245ab</span><br><span class="line">main将com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@7cc355be加入任务队列：</span><br><span class="line">main将com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@6e8cf4c6加入任务队列：</span><br><span class="line">Thread-0 0</span><br><span class="line">救火队员 4</span><br><span class="line">Thread-1 1</span><br><span class="line">救火队员 3</span><br><span class="line">Thread-0正在执行：com.concurrency.threadpoolstudy.CreateAThreadpool$$Lambda$2&#x2F;1867083167@34a245ab</span><br><span class="line">worker被移除Thread[Thread-1,5,main]</span><br><span class="line">Thread-0 2</span><br><span class="line">worker被移除Thread[Thread-0,5,main]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自定义一个线程池&quot;&gt;&lt;a href=&quot;#自定义一个线程池&quot; class=&quot;headerlink&quot; title=&quot;自定义一个线程池&quot;&gt;&lt;/a&gt;自定义一个线程池&lt;/h1&gt;&lt;p&gt;本文尝试实现一个线程池，具体架构如下所示，有以下几个成员&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="https://thisiswilli.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized关键字及进阶</title>
    <link href="https://thisiswilli.cn/2020/03/19/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E8%BF%9B%E9%98%B6/"/>
    <id>https://thisiswilli.cn/2020/03/19/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E8%BF%9B%E9%98%B6/</id>
    <published>2020-03-19T11:24:34.000Z</published>
    <updated>2020-03-19T11:25:47.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Synchronized关键字及进阶"><a href="#Synchronized关键字及进阶" class="headerlink" title="Synchronized关键字及进阶"></a>Synchronized关键字及进阶</h1><p>本文介绍synchronized的基本用法以及一些进阶知识</p><a id="more"></a><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><pre><code>在了解synchronized前，还要了解临界区的概念，在多个线程访问共享资源时，并对共享资源读写操作发生指令交错，就会出现问题，**一个代码块如果存在对共享资源的读写操作**，那么这块代码块就叫做临界区。</code></pre><h2 id="为什么需要synchronized"><a href="#为什么需要synchronized" class="headerlink" title="为什么需要synchronized"></a>为什么需要synchronized</h2><pre><code>synchronized可以通过**阻塞的手段**避免避免临界区代码的竟态条件发生，synchronized用对象锁保证了临界区代码的原子性，临界区的代码对外是不可分割的，不会被其他线程所打断。</code></pre><h2 id="Synchronized用法简介"><a href="#Synchronized用法简介" class="headerlink" title="Synchronized用法简介"></a>Synchronized用法简介</h2><p>synchronized可以根据持有的锁分为持有对象锁和持有类锁两种情况</p><h3 id="持有对象锁"><a href="#持有对象锁" class="headerlink" title="持有对象锁"></a>持有对象锁</h3><p>当持有的是对象锁时可以通过用sychonized直接修饰方法或者修饰方法块，代码template如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于   锁住了this对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>所有线程公用一把锁时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="comment">// 用static修饰是为了让每个线程的锁都为同一个对象</span></span><br><span class="line">    <span class="keyword">static</span> ObjectLock objectLock = <span class="keyword">new</span> ObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"this是  "</span> + <span class="keyword">this</span>.getClass());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(objectLock).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>是  <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-0结束</span></span><br><span class="line"><span class="class"><span class="title">this</span>是  <span class="title">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-4结束</span></span><br><span class="line"><span class="class"><span class="title">this</span>是  <span class="title">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-3结束</span></span><br><span class="line"><span class="class"><span class="title">this</span>是  <span class="title">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-2结束</span></span><br><span class="line"><span class="class"><span class="title">this</span>是  <span class="title">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-1结束</span></span><br></pre></td></tr></table></figure></li><li><p>自定义两把锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line">    <span class="comment">// 创建2把锁</span></span><br><span class="line">    Object block1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object block2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (block1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"block1锁,我是线程"</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"block1锁,"</span>+Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (block2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"block2锁,我是线程"</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"block2锁,"</span>+Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="持有类锁"><a href="#持有类锁" class="headerlink" title="持有类锁"></a>持有类锁</h3><p>持有类锁可以通过用synchronized修饰静态方法或者用synchronized代码块实现，代码template如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于   相当于锁住了类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span><span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现如下：</p><ul><li><p>代码块使用类锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 让每个线程的锁都为同一个对象</span></span><br><span class="line">    <span class="keyword">static</span> ObjectLock objectLock = <span class="keyword">new</span> ObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ObjectLock<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始沉睡"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(objectLock).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0开始沉睡</span><br><span class="line">Thread-0结束</span><br><span class="line">Thread-4开始沉睡</span><br><span class="line">Thread-4结束</span><br><span class="line">Thread-3开始沉睡</span><br><span class="line">Thread-3结束</span><br><span class="line">Thread-2开始沉睡</span><br><span class="line">Thread-2结束</span><br><span class="line">Thread-1开始沉睡</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure></li><li><p>用synchronized修饰静态方法使用类锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 让每个线程的锁都为同一个对象</span></span><br><span class="line">    <span class="keyword">static</span> ObjectLock objectLock = <span class="keyword">new</span> ObjectLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"在静态方法能使用类锁"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(objectLock).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0在静态方法内使用类锁</span><br><span class="line">Thread-0结束了</span><br><span class="line">Thread-4在静态方法内使用类锁</span><br><span class="line">Thread-4结束了</span><br><span class="line">Thread-3在静态方法内使用类锁</span><br><span class="line">Thread-3结束了</span><br><span class="line">Thread-2在静态方法内使用类锁</span><br><span class="line">Thread-2结束了</span><br><span class="line">Thread-1在静态方法内使用类锁</span><br><span class="line">Thread-1结束了</span><br></pre></td></tr></table></figure><p>也可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedStudy4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(Thread.currentThread().getName() + <span class="string">"在静态方法内使用类锁  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = SynchronizedStudy4::fun;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Synchronized关键字的特点"><a href="#Synchronized关键字的特点" class="headerlink" title="Synchronized关键字的特点"></a>Synchronized关键字的特点</h2><ul><li>Synchronized关键字不能被继承，子类如果要重写父类的synchronized方法，必须显示的加上sychronized关键字</li><li>一把锁只能被一个线程获取，没有获得锁的线程只能等待</li><li>每个实例都有自己的一把锁(this)，不同实例之间不回互相影响，锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁</li><li>synchronized修饰的方法无论是执行完毕还是抛出异常，都会释放锁</li><li>synchronized修饰的方法如果抛出异常是会释放锁的，很容易产生问题，多线程遇到异常时，要好好处理异常，可以在catch中进行回滚</li></ul><p>接下来从原理层面对synchronized关键字进行解析，首先要理解Java对象头的概念</p><h2 id="Java对象头的结构"><a href="#Java对象头的结构" class="headerlink" title="Java对象头的结构"></a>Java对象头的结构</h2><p>java的对象头有一下三部分组成：</p><ul><li><strong>Mark Word</strong></li><li>指向类的指针，即类型指针</li><li>数组长度(只有数组才有)</li></ul><p>java对象头的方式有以下两种，以32位JVM虚拟机为例</p><h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--------------------------------------------------------------|</span><br><span class="line">|                     Object Header (64 bits)                  |</span><br><span class="line">|------------------------------------|-------------------------|</span><br><span class="line">|        Mark Word (32 bits)         |    Klass Word (32 bits) |</span><br><span class="line">|------------------------------------|-------------------------|</span><br></pre></td></tr></table></figure><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------------------------------------------------------------|</span><br><span class="line">|                                 Object Header (96 bits)                         |</span><br><span class="line">|--------------------------------|-----------------------|------------------------|</span><br><span class="line">|        Mark Word(32bits)       |    Klass Word(32bits) |  array length(32bits)  |</span><br><span class="line">|--------------------------------|-----------------------|------------------------|</span><br></pre></td></tr></table></figure><h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p>这部分主要用来存储对象自身的运行时数据，如hashcode、gc分代年龄等。<code>mark word</code>的位长度为JVM的一个Word大小，也就是说32位JVM的<code>Mark word</code>为32位，64位JVM为64位。<br> 为了让一个字大小存储更多的信息，JVM将字的最低两个位设置为标记位，不同标记位下的Mark Word示意如下：</p><img src="https://img-blog.csdn.net/20180518151408659" style="zoom:60%;" /><h2 id="Monitor简介"><a href="#Monitor简介" class="headerlink" title="Monitor简介"></a>Monitor简介</h2><p>monitor被称为监视器或者管程</p><pre><code>每个Java对象都可以关联一个monitor对象，如果使用synchronized给对象上锁之后，该对象头的markword就被设置指向monitor对象的指针。</code></pre><h3 id="monitor工作原理"><a href="#monitor工作原理" class="headerlink" title="monitor工作原理"></a>monitor工作原理</h3><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/monitor.png" alt=""></p><p>注意</p><ul><li>synchronized必须是进入到<strong>同一个对象的monitor</strong>才有上述的效果</li><li>不加synchronized的对象不会关联监视器，不遵守以上规则</li></ul><h3 id="从字节码角度分析monitor"><a href="#从字节码角度分析monitor" class="headerlink" title="从字节码角度分析monitor"></a>从字节码角度分析monitor</h3><p>编写如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorByteCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将java文件编译成字节码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac MonitorByteCode.java</span><br></pre></td></tr></table></figure><p>反编译class文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c MonitorByteCode</span><br></pre></td></tr></table></figure><p>得到字节码，部分字节码如下所示， 考虑是否会出现异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  Code:</span><br><span class="line">     0: getstatic     #2                  &#x2F;&#x2F; lock引用  synchronized开始</span><br><span class="line">     3: dup&#x2F;&#x2F; 复制一份</span><br><span class="line">     4: astore_1&#x2F;&#x2F; 将lock引用存储到slot1中</span><br><span class="line">     5: monitorenter&#x2F;&#x2F; 将Lock对象中的MarkWord置为Monitor指针</span><br><span class="line">     6: getstatic     #3                  &#x2F;&#x2F; &lt;--i</span><br><span class="line">     9: iconst_1&#x2F;&#x2F; 准备常数i</span><br><span class="line">    10: iadd&#x2F;&#x2F; +1</span><br><span class="line">    11: putstatic     #3                  &#x2F;&#x2F; 将i赋值</span><br><span class="line">    14: aload_1&#x2F;&#x2F; 找到之前astore_1中存储的临时变量中的引用，通过其中的mark默认头找到monitor这个锁，</span><br><span class="line">    15: monitorexit&#x2F;&#x2F; 唤醒EntryList中等待的线程</span><br><span class="line">    16: goto          24</span><br><span class="line">    19: astore_2&#x2F;&#x2F; 将异常对象e-&gt;存储到slot2中</span><br><span class="line">    20: aload_1&#x2F;&#x2F; &lt;--lock引用</span><br><span class="line">    21: monitorexit&#x2F;&#x2F; 将Lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">    22: aload_2</span><br><span class="line">    23: athrow</span><br><span class="line">    24: return</span><br><span class="line">    &#x2F;&#x2F; 检查是否会出现异常</span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         6    16    19   any</span><br><span class="line">        19    22    19   any</span><br></pre></td></tr></table></figure><p>在没有别的线程竞争的情况下，优先使用的是轻量级锁</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><pre><code>轻量级锁使用场景：如果一个对象虽然有多线程访问，但是多线程访问的时间是错开的(也就是没有竞争)，那么可以使用轻量级锁来优化。**轻量级锁对使用者是透明的，是JVM层面的**，系统在运行时会先使用轻量级锁，如果轻量级锁不起作用，在使用重量级锁</code></pre><p>如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorByteCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建锁记录(Lock Record)对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%A0%88%E4%B8%AD%E5%88%9B%E5%BB%BALockRecord%E5%AF%B9%E8%B1%A1.png" style="zoom:50%;" /></li><li><p>让锁记录中的Object reference指向锁对象，并尝试用CAS替换Object中的Mark Word，将MarkWord中的值存入锁记录，其中Mark Word的值为00时，对应的是轻量级锁</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E6%9B%BF%E6%8D%A2%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%88%90%E5%8A%9F.png" style="zoom:50%;" /></li><li><p>如果CAS替换成功，锁对象的对象头中存储了锁记录地址和状态00，表示该线程给对象加锁</p></li><li><p>如果CAS失败，有两种情况</p><ul><li><p>如果其他线程持有了object的轻量级锁，这时表明有竞争，进入锁膨胀过程，锁膨胀过程后面解释</p></li><li><p>如果自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数，重入几次，就会有几个Lock Record，下图为重入的情况</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E9%94%81%E9%87%8D%E5%85%A5.png" style="zoom:50%;" /></li></ul></li><li><p>现在进入解锁过程，当退出synchronized代码块时(也就是解锁)如果有取值位null的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p></li><li><p>当退出synchronized代码块时，锁记录的值不为null，这时使用CAS将Mark Word的值恢复给对象头</p><ul><li><p>成功，则解锁成功</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E9%80%80%E5%87%BA%E5%B9%B6%E8%A7%A3%E9%94%81.png" style="zoom:50%;" /></li></ul></li></ul><ul><li>失败，说明轻量级锁进行了锁膨胀已经升级为重量级锁，进入重量级锁解锁流程</li></ul><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorByteCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是其他线程为此对象加上了轻量级锁(有竞争)，**这是需要进行锁膨胀，将轻量级锁变为重量级锁**</code></pre><ul><li><p>当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E9%94%81%E8%86%A8%E8%83%80.png" style="zoom:50%;" /></li><li><p>这是Thread-1加轻量级锁失败，进入锁膨胀流程</p><ul><li>即为加锁对象申请Monitor锁，让Object指向重量级锁地址，</li><li>然后自己进入Monitor的EntryList Blocked</li></ul><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E4%B8%BAObject%E5%AF%B9%E8%B1%A1%E7%94%B3%E8%AF%B7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.png" style="zoom:50%;" /></li><li><p>当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败，这是会进入重量级锁的解锁流程即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中的Blocked线程</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E8%A7%A3%E9%94%81.png" style="zoom:50%;" /></li></ul><h2 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h2><pre><code>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功(即当前持有锁的线程退出了同步块释放了锁)，这时当前线程就可以获得锁，避免阻塞，阻塞会发生上下文切换，耗费资源，**多核cpu下才有意义**</code></pre><ul><li>Java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功率会比较高，就多自旋几次，反之，就少自旋，甚至不自旋。</li><li>自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU才能发挥优势</li><li>Java7之后不能控制是否开启自旋功能</li></ul><h2 id="偏向锁优化"><a href="#偏向锁优化" class="headerlink" title="偏向锁优化"></a>偏向锁优化</h2><pre><code>**由于轻量级锁在没有竞争的情况下，重入时仍然要执行CAS操作**Java6中引入了偏向锁来做进一步优化：**只有第一次使用CAS将线程ID设置到锁对象的MarkWord头**，之后发现这个线程id是自己的就表示没有竞争，不用重新CAS，以后只要不发生竞争，这个对象就归该线程所有</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorByteCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">method3();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原先如果没有使用偏向锁，那么每次锁重入时，如下所示</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E5%8E%9F%E5%85%88%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" style="zoom:50%;" /><p>如果使用偏向锁优化，如下所示</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E5%81%8F%E5%90%91%E9%94%81%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E9%87%8D%E5%85%A5.png" style="zoom:50%;" /><h3 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h3><p>再看对象头</p><p><img src="https://img-blog.csdn.net/20180518151408659" alt=""></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁(默认开启)，那么对象创建之后，mark word的值为0x05，即对象头的后三位为101，但是线程ID，Epoch，分代年龄都为0</li><li>偏向锁默认是延迟的，如果想要程序启动就开启偏向锁，需要在VM参数中进行设置</li><li>如果没有开启偏向锁，那么对象创建后，markword值为0x01即最后三位为001，对应上图中的无锁状态</li></ul><p>根据场景决定是否使用偏向锁</p><h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><h4 id="即调用对象的hashCode"><a href="#即调用对象的hashCode" class="headerlink" title="即调用对象的hashCode"></a>即调用对象的hashCode</h4><pre><code>由于偏向锁对象的MarkWord中存储的是线程ID，调用了hashcode，会让锁标志位从101切换到001，即变为无锁状态，进而导致偏向锁被取消</code></pre><ul><li>轻量级锁会在锁记录中记录hashCode</li><li>重量级锁会在Monitor对象中记录hashCode</li></ul><h4 id="其他线程使用对象"><a href="#其他线程使用对象" class="headerlink" title="其他线程使用对象"></a>其他线程使用对象</h4><p>当其他线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><h4 id="调用wait-notify时也会撤销"><a href="#调用wait-notify时也会撤销" class="headerlink" title="调用wait/notify时也会撤销"></a>调用wait/notify时也会撤销</h4><p>因为wait/notify只有重量级锁才能使用</p><h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><pre><code>如果对象背多个线程访问，但没有竞争，这时偏向T1的对象仍有机会重新偏向T2，重偏向会重置对象的ThreadID，当撤销偏向锁阈值超过20次后，JVM会认为自己可能偏向错了，于是会在给这些对象加锁时重新偏向加锁线程。</code></pre><h3 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3><pre><code>当撤销偏量锁超过40次后，jvm会认为自己就不应该偏向，于是，整个类所有对象都变为不可偏向， 新建的对象也是不可偏向的。</code></pre><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><pre><code>涉及到jvm对没有竞态条件的代码，即在没有多线程竞争的产生竞态条件的代码块上却加了锁的情况，jvm底层会对这种情况进行优化，自动消除锁。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Synchronized关键字及进阶&quot;&gt;&lt;a href=&quot;#Synchronized关键字及进阶&quot; class=&quot;headerlink&quot; title=&quot;Synchronized关键字及进阶&quot;&gt;&lt;/a&gt;Synchronized关键字及进阶&lt;/h1&gt;&lt;p&gt;本文介绍synchronized的基本用法以及一些进阶知识&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从操作系统和JavaAPI层面解释线程的状态</title>
    <link href="https://thisiswilli.cn/2020/03/19/%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8CJavaAPI%E5%B1%82%E9%9D%A2%E8%A7%A3%E9%87%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <id>https://thisiswilli.cn/2020/03/19/%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8CJavaAPI%E5%B1%82%E9%9D%A2%E8%A7%A3%E9%87%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</id>
    <published>2020-03-19T07:57:57.000Z</published>
    <updated>2020-04-23T11:17:43.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从操作系统和JavaAPI层面解释线程的状态"><a href="#从操作系统和JavaAPI层面解释线程的状态" class="headerlink" title="从操作系统和JavaAPI层面解释线程的状态"></a>从操作系统和JavaAPI层面解释线程的状态</h1><p>本文从操作系统和JavaAPI两个层面分别解释线程的状态</p><a id="more"></a><h2 id="从操作系统层面来看"><a href="#从操作系统层面来看" class="headerlink" title="从操作系统层面来看"></a>从操作系统层面来看</h2><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E7%BA%BF%E7%A8%8B%E7%9A%845%E4%B8%AD%E7%8A%B6%E6%80%81.png" style="zoom:25%;" /><ul><li>初始状态：仅在语言层面创建了对象，还未与操作系统建立联系</li><li>可运行状态：也可以称其为就绪状态，指该线程已经被创建(与操作系统相关联)，可以由CPU调度运行</li><li>运行状态：线程已经获得了CPU时间片并在运行的状态，当cpu的时间片用完，线程会从运行状态切换到可运行状态，会导致线程的上下文切换</li><li>阻塞状态<ul><li>如果调用了阻塞的API，例如BIO读写文件，该线程不会用到CPU，会导致线程上下文切换，进入阻塞状态，调度器不会将时间片分给阻塞状态的线程</li><li>等BIO操作完成之后，由操作系统唤醒处于阻塞状态的线程，该线程状态从阻塞状态切换到可运行状态</li><li>可运行状态与阻塞状态的区别就是，阻塞状态的线程如果一直不被唤醒，那么调度器永远不会考虑它们</li></ul></li><li>终止状态：线程已经执行完毕，生命周期已经结束</li></ul><h2 id="从JavaAPI层面来理解"><a href="#从JavaAPI层面来理解" class="headerlink" title="从JavaAPI层面来理解"></a>从JavaAPI层面来理解</h2><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E4%BB%8EJavaAPI%E5%B1%82%E9%9D%A2%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81%20%281%29.png" alt=""></p><p>在JavaAPI层面，线程主要有以下几种状态</p><ul><li>NEW：线程刚刚被创建，还没有调用start()方法</li><li>RUNNABLE：当调用了start()方法之后，JavaAPI层面的RUNNABLE状态涵盖了操作系统层面的可运行状态，运行状态，阻塞状态</li><li>BLOCK：线程争夺锁失败，正在等待锁的释放，或者是线程在争夺锁的状态</li><li>WAITING：调用了join，wait方法的线程，可以被操作系统再次唤醒</li><li>TIME_WAITING：调用了sleep方法的线程</li><li>TERMINATED：当线程代码运行结束</li></ul><h3 id="NEW-–-gt-RUNNABLE"><a href="#NEW-–-gt-RUNNABLE" class="headerlink" title="NEW –&gt;  RUNNABLE"></a>NEW –&gt;  RUNNABLE</h3><ul><li>当调用<code>Thread.start()</code>方法时从NEW–&gt;RUNNABLE</li></ul><h3 id="RUNNABLE-lt-–-gt-WAITING"><a href="#RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="RUNNABLE &lt;–&gt; WAITING"></a>RUNNABLE &lt;–&gt; WAITING</h3><p>情况一：</p><ul><li><p><strong>t线程</strong>使用synchronized获取对象锁之后</p><ul><li><p>调用<code>obj.wait()</code>方法时，t线程从RUNNABLE –&gt; WAITING，并且释放了锁</p></li><li><p>调用<code>obj.notify(),obj.notifyAll(),t.interrupt()</code>时，</p><ul><li>竞争锁成功，t线程从WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t线程从WAITING–&gt;BLOCKED</li></ul></li></ul></li></ul><p>情况二：</p><ul><li><p>当前线程调用<code>t.join()</code>方法时当前线程从RUNNABLE –&gt; WAITING</p><ul><li><strong>注意是当前线程在t线程对象的Monitor上等待</strong></li></ul></li><li><p>t线程运行结束，或调用了当前线程的<code>interrupt()</code>时，当前线程从WAITING –&gt; RUNNABLE</p></li></ul><p>情况三：</p><ul><li>当前线程调用<code>LockSupport.park()</code>方法会让当前线程从RUNNABLE –&gt; WAITING</li><li>调用Lock Support.unpack(目标线程)或调用了线程的interrupt()，会让目标线程从WAITING–&gt;RUNNABLE</li></ul><h3 id="RUNNABLE-lt-–-gt-TIME-WAITING"><a href="#RUNNABLE-lt-–-gt-TIME-WAITING" class="headerlink" title="RUNNABLE &lt;–&gt; TIME_WAITING"></a>RUNNABLE &lt;–&gt; TIME_WAITING</h3><p>情况一：</p><ul><li><p><strong>t线程</strong>使用synchronized获取对象锁之后</p></li><li><p>调用<code>obj.wait(long n)</code>方法时，t线程从RUNNABLE –&gt; TIME_WAITING</p></li><li><p>t线程等待时间超过了n毫秒，或调用<code>obj.notify(),obj.notifyAll(),t.interrupt()</code>时，</p><ul><li>竞争锁成功，t线程从TIME_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t线程从TIME_WAITING–&gt;BLOCKED</li></ul></li></ul><p>情况二：</p><ul><li>当前线程调用<code>t.join(long n)</code>方法时当前线程从RUNNABLE –&gt; TIME_WAITING<ul><li>注意是当前线程在t线程对象的Monitor上等待</li></ul></li><li>当前线程等待时间超过了n毫秒，或t线程运行结束，或调用了当前线程的interrupt()时，当前线程从TIME_WAITING–&gt;RUNNABLE</li></ul><p>情况三：</p><ul><li>当前线程调用<code>t.sleep(long n)</code>，当前线程从RUNNABLE–&gt;TIME_WAITING</li><li>当前线程等待时间超过了n毫秒，当前线程从TIME_WAITING –&gt; RUNNABLE</li></ul><p>情况四：</p><ul><li>当前线程调用<code>LockSupport.parkNanos(long nanos)</code>方法或<code>LockSupport.parkUtil(long millis</code>)会让当前线程从RUNNABLE –&gt; TIME_WAITING</li><li>调用<code>LockSupport.unpack(目标线程)</code>或调用了线程的<code>interrupt()</code>，会让目标线程从TIME_WAITING–&gt;RUNNABLE</li></ul><h3 id="RUNNABLE-lt-–-gt-BLOCKED"><a href="#RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="RUNNABLE &lt;–&gt; BLOCKED"></a>RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t线程使用synchronized获取了对象锁时如果竞争失败，从RUNNABLE  –&gt; BLOCKED</li><li>持obj锁线程的同步代码块执行完毕，会唤醒该对象上所有BLOCKED的线程重新竞争，如果其中t线程竞争成功，从BLOCK–&gt;RUNNABLE，其他失败的线程仍然BLOCKED</li></ul><h3 id="RUNNABLE-lt-–-gt-TERMINATED"><a href="#RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="RUNNABLE &lt;–&gt; TERMINATED"></a>RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线程所有代码运行完毕，进入TERMINATED</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从操作系统和JavaAPI层面解释线程的状态&quot;&gt;&lt;a href=&quot;#从操作系统和JavaAPI层面解释线程的状态&quot; class=&quot;headerlink&quot; title=&quot;从操作系统和JavaAPI层面解释线程的状态&quot;&gt;&lt;/a&gt;从操作系统和JavaAPI层面解释线程的状态&lt;/h1&gt;&lt;p&gt;本文从操作系统和JavaAPI两个层面分别解释线程的状态&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SparkCore源码阅读之SparkContext,SparkConf,SparkEnv</title>
    <link href="https://thisiswilli.cn/2020/03/16/SparkCore%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BSparkContext-SparkConf-SparkEnv/"/>
    <id>https://thisiswilli.cn/2020/03/16/SparkCore%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BSparkContext-SparkConf-SparkEnv/</id>
    <published>2020-03-16T14:40:57.000Z</published>
    <updated>2020-04-23T11:24:18.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SparkCore之SparkContext-SparkConf"><a href="#SparkCore之SparkContext-SparkConf" class="headerlink" title="SparkCore之SparkContext,SparkConf"></a>SparkCore之SparkContext,SparkConf</h1><p>本文记录SparkCore,SparkContext,SparkConf源码阅读笔记</p><a id="more"></a><h2 id="Spark程序入口"><a href="#Spark程序入口" class="headerlink" title="Spark程序入口"></a>Spark程序入口</h2><p>​        我们在编写Spark程序时，程序的入口一般都需创建SparkConf，设置SparkConf中的属性，再将SparkConf传入SparkContext中，比如一个简单的map算子程序，接下来通过SparkConf，SparkContext的源码，来解读Spark程序初始化的过程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">map</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"map"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    sc.setLogLevel(<span class="string">"Error"</span>)</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">val</span> lines = sc.textFile(<span class="string">"data/data.txt"</span>)</span><br><span class="line">    lines.map(one=&gt;&#123;</span><br><span class="line">      one + <span class="string">"#"</span></span><br><span class="line">    &#125;).foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SparkConf"><a href="#SparkConf" class="headerlink" title="SparkConf"></a>SparkConf</h2><p>SparkConf是Spark application的配置类，SparkConf主要有以下几点功能以及特点：</p><ul><li><p>在读取SparkConf参数时，SparkConf会先读取org.apache.spark下任何关于SparkConf的配置，是否读取读取默认参数可以在创建SparkConf时通过传入true或false进行设置，但是开发者通过set方法设置的SparkConf属性的优先级是高于系统设置的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">loadFromSystemProperties</span></span>(silent: <span class="type">Boolean</span>): <span class="type">SparkConf</span> = &#123;</span><br><span class="line">    <span class="comment">// Load any spark.* system properties</span></span><br><span class="line">    <span class="keyword">for</span> ((key, value) &lt;- <span class="type">Utils</span>.getSystemProperties <span class="keyword">if</span> key.startsWith(<span class="string">"spark."</span>)) &#123;</span><br><span class="line">      set(key, value, silent)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>开发者可以在SparkConf中set SparkConf中的各种参数，其中set方法都支持链式书写，如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conf.setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"map"</span>)</span><br></pre></td></tr></table></figure><p>开发者也可以通过get获取SparkConf中的参数，部分源码如下所示</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The master URL to connect to, such as "local" to run locally with one thread, "local[4]" to</span></span><br><span class="line"><span class="comment">   * run locally with 4 cores, or "spark://master:7077" to run on a Spark standalone cluster.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setMaster</span></span>(master: <span class="type">String</span>): <span class="type">SparkConf</span> = &#123;</span><br><span class="line">    set(<span class="string">"spark.master"</span>, master)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Set a name for your application. Shown in the Spark web UI. */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setAppName</span></span>(name: <span class="type">String</span>): <span class="type">SparkConf</span> = &#123;</span><br><span class="line">    set(<span class="string">"spark.app.name"</span>, name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Get a parameter; throws a NoSuchElementException if it's not set */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(key: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    getOption(key).getOrElse(<span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(key))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get a parameter, falling back to a default if not set */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(key: <span class="type">String</span>, defaultValue: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    getOption(key).getOrElse(defaultValue)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>SparkConf也定义了一个伴生对象来记录已经弃用的配置</p></li></ul><h2 id="SparkEnv"><a href="#SparkEnv" class="headerlink" title="SparkEnv"></a>SparkEnv</h2><p>SparkEnv是Spark运行程序的运行环境，SparkEnv中保留正在运行的Spark实例（主实例或工作实例）的所有运行时环境对象，SparkEnv类的构造函数如下，可见这个类中定义了Spark application运行时的环境对象</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparkEnv</span> (<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    val executorId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    private[spark] val rpcEnv: <span class="type">RpcEnv</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val serializer: <span class="type">Serializer</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val closureSerializer: <span class="type">Serializer</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val serializerManager: <span class="type">SerializerManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val mapOutputTracker: <span class="type">MapOutputTracker</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val shuffleManager: <span class="type">ShuffleManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val broadcastManager: <span class="type">BroadcastManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val blockManager: <span class="type">BlockManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val securityManager: <span class="type">SecurityManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val metricsSystem: <span class="type">MetricsSystem</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val memoryManager: <span class="type">MemoryManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val outputCommitCoordinator: <span class="type">OutputCommitCoordinator</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val conf: <span class="type">SparkConf</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">var</span> isStopped = <span class="literal">false</span></span><br><span class="line">  ....&#125;</span><br></pre></td></tr></table></figure><p>SparkContext在执行Spark application时会根据SparkConf中的设置，通过阅读SparkEnv源码中的create方法可知，SparkEnv中的运行时环境对象创建顺序如下所示，接下来我们逐个分析</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Spark/SparkEnv%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" style="zoom:25%;" /><h3 id="安全管理器SecurityManager"><a href="#安全管理器SecurityManager" class="headerlink" title="安全管理器SecurityManager"></a>安全管理器SecurityManager</h3><p>create方法中创建SecurityManager的代码如下所示，创建SecurityManager需要SparkConf中的设置以及io加密的密钥</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> securityManager = <span class="keyword">new</span> <span class="type">SecurityManager</span>(conf, ioEncryptionKey)</span><br><span class="line">    <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">      securityManager.initializeAuth()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioEncryptionKey.foreach &#123; _ =&gt;</span><br><span class="line">      <span class="keyword">if</span> (!securityManager.isEncryptionEnabled()) &#123;</span><br><span class="line">        logWarning(<span class="string">"I/O encryption enabled without RPC encryption: keys will be visible on the "</span> +<span class="string">"wire."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再看SecurityManager这个类，顾名思义，主要负责安全，主要有以下几个特点</p><ul><li><p>SecurityManager可以设置集群中的通信方式，Spark集群之间默认可以通过公钥来进行验证并通信，可以配置“ spark.authenticate”将身份验证设置为启用，进一步提高安全性</p></li><li><p>也可以通过javax servlet过滤器让对特定数据没有访问权限的用户无法访问相应的SparkUI</p></li><li><p>Spark通过个人和小组修改ACL（<code>spark.modify.acls</code>）和（<code>spark.modify.acls.groups</code>）控制哪些用户和组织有权访问修改单个Spark application</p></li><li><p>如果使用Hadoop YARN作为集群管理器，则需要使用证书生成secret key登录，最后给当前系统设置默认的口令认证实例</p></li></ul><h3 id="RPC通信环境RpcEnv"><a href="#RPC通信环境RpcEnv" class="headerlink" title="RPC通信环境RpcEnv"></a>RPC通信环境RpcEnv</h3><p>create中创建RPCEnv的代码如下所示</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rpcEnv = <span class="type">RpcEnv</span>.create(systemName, bindAddress, advertiseAddress, port.getOrElse(<span class="number">-1</span>), conf,</span><br><span class="line">      securityManager, numUsableCores, !isDriver)</span><br></pre></td></tr></table></figure><p>关于RPC的分析可以参考<a href="https://zhuanlan.zhihu.com/p/28893155" target="_blank" rel="noopener">这篇文章</a></p><h3 id="序列化管理器serializerManager"><a href="#序列化管理器serializerManager" class="headerlink" title="序列化管理器serializerManager"></a>序列化管理器serializerManager</h3><p>​        序列化管理器通过用来配置各Spark组件的序列化、压缩和加密。serializer默认实现为org.apache.spark.serializer.JavaSerializer，用户可以通过在SparkConf中自定义序列化器的类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serializer = instantiateClassFromConf[<span class="type">Serializer</span>](</span><br><span class="line">      <span class="string">"spark.serializer"</span>, <span class="string">"org.apache.spark.serializer.JavaSerializer"</span>)</span><br><span class="line">    logDebug(<span class="string">s"Using serializer: <span class="subst">$&#123;serializer.getClass&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> serializerManager = <span class="keyword">new</span> <span class="type">SerializerManager</span>(serializer, conf, ioEncryptionKey)</span><br></pre></td></tr></table></figure><h3 id="闭包序列化器closureSerializer"><a href="#闭包序列化器closureSerializer" class="headerlink" title="闭包序列化器closureSerializer"></a>闭包序列化器closureSerializer</h3><p>闭包序列化器只能为java内置序列化器，不支持用户自定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> closureSerializer = <span class="keyword">new</span> <span class="type">JavaSerializer</span>(conf)</span><br></pre></td></tr></table></figure><h3 id="广播管理器broadcastManager"><a href="#广播管理器broadcastManager" class="headerlink" title="广播管理器broadcastManager"></a>广播管理器broadcastManager</h3><p>​        create方法中创建broadcastManager代码如下所示，BroadcastManager用于将配置信息和序列化后的RDD、Job以及ShuffleDependency等信息在本地存储。如果为了容灾，也会复制到其他节点上</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> broadcastManager = <span class="keyword">new</span> <span class="type">BroadcastManager</span>(isDriver, conf, securityManager)</span><br></pre></td></tr></table></figure><p>###Map任务输出跟踪器mapOutputTracker </p><p>MapOutputTracker 用于跟踪 stage中map任务输出结果的位置</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mapOutputTracker = <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="type">MapOutputTrackerMaster</span>(conf, broadcastManager, isLocal)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="type">MapOutputTrackerWorker</span>(conf)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>MapOutputTrackerMaster属于Driver，负责追踪当前Spark application上所有Shuffle的Map输出元数据信息</li><li>MapOutputTrackerWorker是运行在Executor中的，负责拉取MapOutputTrackerMaster端的map输出数据，进行reduce任务</li></ul><h3 id="ShuffleManager"><a href="#ShuffleManager" class="headerlink" title="ShuffleManager"></a>ShuffleManager</h3><p>​        Spark的stage与stage之间的过程就是 shuffle 阶段，在 Spark 中，负责 shuffle 过程的执行、计算和处理的组件主要就是 <strong>ShuffleManager</strong> 。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> shuffleManager = instantiateClass[<span class="type">ShuffleManager</span>](shuffleMgrClass)</span><br></pre></td></tr></table></figure><h3 id="MemoryManager"><a href="#MemoryManager" class="headerlink" title="MemoryManager"></a>MemoryManager</h3><p>​        一种抽象内存管理器，用于强制执行和存储之间共享内存的方式。在这个上下文下，执行内存是指用于在shuffle，join，sort和aggregation中进行计算的内存，而存储内存是指用于在群集中缓存和传播内部数据的内存。 每个JVM都有一个MemoryManager。</p><p>​        UnifiedMemoryManager和StaticMemoryManager继承了MemoryManager这个抽象类，spark1.6+默认使用UnifiedMemoryManager</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> useLegacyMemoryManager = conf.getBoolean(<span class="string">"spark.memory.useLegacyMode"</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> memoryManager: <span class="type">MemoryManager</span> =</span><br><span class="line">      <span class="keyword">if</span> (useLegacyMemoryManager) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">StaticMemoryManager</span>(conf, numUsableCores)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">UnifiedMemoryManager</span>(conf, numUsableCores)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="blockManager"><a href="#blockManager" class="headerlink" title="blockManager"></a>blockManager</h3><p>blockManager运行在每个节点上，包括driver和Executor，提供对本地或远端节点上的内存、磁盘及堆外内存中Block的管理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NB: blockManager is not valid until initialize() is called later.</span></span><br><span class="line"><span class="keyword">val</span> blockManager = <span class="keyword">new</span> <span class="type">BlockManager</span>(executorId, rpcEnv, blockManagerMaster,</span><br><span class="line">      serializerManager, conf, memoryManager, mapOutputTracker, shuffleManager,</span><br><span class="line">      blockTransferService, securityManager, numUsableCores)</span><br></pre></td></tr></table></figure><h3 id="metricsSystem"><a href="#metricsSystem" class="headerlink" title="metricsSystem"></a>metricsSystem</h3><p>Spark中的master, worker, executor, client driver都可以创建metricsSystem，metricsSytem用来监控Spark组件中的各种指标信息，例如MasterSource, WorkerSource或JvmSource，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> metricsSystem = <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">      <span class="comment">// Don't start metrics system right now for Driver.</span></span><br><span class="line">      <span class="comment">// We need to wait for the task scheduler to give us an app ID.</span></span><br><span class="line">      <span class="comment">// Then we can start the metrics system.</span></span><br><span class="line">      <span class="type">MetricsSystem</span>.createMetricsSystem(<span class="string">"driver"</span>, conf, securityManager)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We need to set the executor ID before the MetricsSystem is created because sources and</span></span><br><span class="line">      <span class="comment">// sinks specified in the metrics configuration file will want to incorporate this executor's</span></span><br><span class="line">      <span class="comment">// ID into the metrics they report.</span></span><br><span class="line">      conf.set(<span class="string">"spark.executor.id"</span>, executorId)</span><br><span class="line">      <span class="keyword">val</span> ms = <span class="type">MetricsSystem</span>.createMetricsSystem(<span class="string">"executor"</span>, conf, securityManager)</span><br><span class="line">      ms.start()</span><br><span class="line">      ms</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="outputCommitCoordinator"><a href="#outputCommitCoordinator" class="headerlink" title="outputCommitCoordinator"></a>outputCommitCoordinator</h3><p>决定任务是否可以将输出数据提交到HDFS</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> outputCommitCoordinator = mockOutputCommitCoordinator.getOrElse &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">OutputCommitCoordinator</span>(conf, isDriver)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="SparkContext"><a href="#SparkContext" class="headerlink" title="SparkContext"></a>SparkContext</h2><p>​        SparkContext是Spark application的主要入口，SparkContext代表着应用程序与Spark集群的连接，开发者可以使用SparkContext在集群中创建RDD，累加器，或者广播变量。需要注意的是，在每个JVM中只能有一个正在运行的SparkContext，如果要让新的SparkContext在JVM中运行，必须先停止正在运行的SparkContext。</p><p>创建的大致流程图如下</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/SparkContext%E6%B5%81%E7%A8%8B.001.png" style="zoom:70%;" /><ul><li><p>SparkContext在创建之前，会确认是否允许多个SparkContext同时在JVM中运行，如果Spark允许，那么只生成警告，若不允许则抛出异常</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If true, log warnings instead of throwing exceptions when multiple SparkContexts are active</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> allowMultipleContexts: <span class="type">Boolean</span> =</span><br><span class="line">    config.getBoolean(<span class="string">"spark.driver.allowMultipleContexts"</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In order to prevent multiple SparkContexts from being active at the same time, mark this</span></span><br><span class="line">  <span class="comment">// context as having started construction.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> this must be placed at the beginning of the SparkContext constructor.</span></span><br><span class="line">  <span class="type">SparkContext</span>.markPartiallyConstructed(<span class="keyword">this</span>, allowMultipleContexts)</span><br></pre></td></tr></table></figure></li><li><p>接下来SparkContext中定义了以下这些私有变量，这其中有很多Spark application创建过程中的重要组件，这些变量是只能通过SparkContext中定义的一系列类似java类中的get方法来访问的，但是在运行过程中是不能够改变的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _conf: <span class="type">SparkConf</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _eventLogDir: <span class="type">Option</span>[<span class="type">URI</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _eventLogCodec: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _listenerBus: <span class="type">LiveListenerBus</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _env: <span class="type">SparkEnv</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _statusTracker: <span class="type">SparkStatusTracker</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _progressBar: <span class="type">Option</span>[<span class="type">ConsoleProgressBar</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _ui: <span class="type">Option</span>[<span class="type">SparkUI</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _hadoopConfiguration: <span class="type">Configuration</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _executorMemory: <span class="type">Int</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _schedulerBackend: <span class="type">SchedulerBackend</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _taskScheduler: <span class="type">TaskScheduler</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _heartbeatReceiver: <span class="type">RpcEndpointRef</span> = _</span><br><span class="line"> <span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _dagScheduler: <span class="type">DAGScheduler</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _applicationId: <span class="type">String</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _applicationAttemptId: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _eventLogger: <span class="type">Option</span>[<span class="type">EventLoggingListener</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _executorAllocationManager: <span class="type">Option</span>[<span class="type">ExecutorAllocationManager</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _cleaner: <span class="type">Option</span>[<span class="type">ContextCleaner</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _listenerBusStarted: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _jars: <span class="type">Seq</span>[<span class="type">String</span>] = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _files: <span class="type">Seq</span>[<span class="type">String</span>] = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _shutdownHookRef: <span class="type">AnyRef</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _statusStore: <span class="type">AppStatusStore</span> = _</span><br></pre></td></tr></table></figure></li><li><p>在创建SparkContext的过程中，会检查SparkConf中的配置是否完整，如果缺少某些关键配置，则会抛出异常，并判断是以什么形式提交Spark任务</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_conf.contains(<span class="string">"spark.master"</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"A master URL must be set in your configuration"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_conf.contains(<span class="string">"spark.app.name"</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"An application name must be set in your configuration"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log out spark.app.name in the Spark driver logs</span></span><br><span class="line">    logInfo(<span class="string">s"Submitted application: <span class="subst">$appName</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// System property spark.yarn.app.id must be set if user code ran by AM on a YARN cluster</span></span><br><span class="line">    <span class="keyword">if</span> (master == <span class="string">"yarn"</span> &amp;&amp; deployMode == <span class="string">"cluster"</span> &amp;&amp; !_conf.contains(<span class="string">"spark.yarn.app.id"</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"Detected yarn cluster mode, but isn't running on a cluster. "</span> +</span><br><span class="line">        <span class="string">"Deployment to YARN is not supported directly by SparkContext. Please use spark-submit."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_conf.getBoolean(<span class="string">"spark.logConf"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      logInfo(<span class="string">"Spark configuration:\n"</span> + _conf.toDebugString)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来SparkContext会对Driver进行一系列配置，部分代码如下所示</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set Spark driver host and port system properties. This explicitly sets the configuration</span></span><br><span class="line">   <span class="comment">// instead of relying on the default value of the config constant.</span></span><br><span class="line">   _conf.set(<span class="type">DRIVER_HOST_ADDRESS</span>, _conf.get(<span class="type">DRIVER_HOST_ADDRESS</span>))</span><br><span class="line">   _conf.setIfMissing(<span class="string">"spark.driver.port"</span>, <span class="string">"0"</span>)</span><br><span class="line">  </span><br><span class="line">   _conf.set(<span class="string">"spark.executor.id"</span>, <span class="type">SparkContext</span>.<span class="type">DRIVER_IDENTIFIER</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Create the Spark execution environment (cache, map output tracker, etc)</span></span><br><span class="line">   _env = createSparkEnv(_conf, isLocal, listenerBus)</span><br><span class="line">   <span class="type">SparkEnv</span>.set(_env)</span><br></pre></td></tr></table></figure></li><li><p>在创建TaskScheduler之前创建Sparkui，这样能让Sparkui更好监听Spark任务中的各项指标</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ui =</span><br><span class="line">      <span class="keyword">if</span> (conf.getBoolean(<span class="string">"spark.ui.enabled"</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="type">Some</span>(<span class="type">SparkUI</span>.create(<span class="type">Some</span>(<span class="keyword">this</span>), _statusStore, _conf, _env.securityManager, appName, <span class="string">""</span>,</span><br><span class="line">          startTime))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For tests, do not enable the UI</span></span><br><span class="line">        <span class="type">None</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// Bind the UI before starting the task scheduler to communicate</span></span><br><span class="line">    <span class="comment">// the bound port to the cluster manager properly</span></span><br><span class="line">    _ui.foreach(_.bind())</span><br></pre></td></tr></table></figure></li><li><p>接下来对Executor的内存大小进行配置，并根据配置创建ExecutorEnv</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_executorMemory = _conf.getOption(<span class="string">"spark.executor.memory"</span>)</span><br><span class="line">      .orElse(<span class="type">Option</span>(<span class="type">System</span>.getenv(<span class="string">"SPARK_EXECUTOR_MEMORY"</span>)))</span><br><span class="line">      .orElse(<span class="type">Option</span>(<span class="type">System</span>.getenv(<span class="string">"SPARK_MEM"</span>))</span><br><span class="line">      .map(warnSparkMem))</span><br><span class="line">      .map(<span class="type">Utils</span>.memoryStringToMb)</span><br><span class="line">      .getOrElse(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert java options to env vars as a work around</span></span><br><span class="line">    <span class="comment">// since we can't set env vars directly in sbt.</span></span><br><span class="line">    <span class="keyword">for</span> &#123; (envKey, propKey) &lt;- <span class="type">Seq</span>((<span class="string">"SPARK_TESTING"</span>, <span class="string">"spark.testing"</span>))</span><br><span class="line">      value &lt;- <span class="type">Option</span>(<span class="type">System</span>.getenv(envKey)).orElse(<span class="type">Option</span>(<span class="type">System</span>.getProperty(propKey)))&#125; &#123;</span><br><span class="line">      executorEnvs(envKey) = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Option</span>(<span class="type">System</span>.getenv(<span class="string">"SPARK_PREPEND_CLASSES"</span>)).foreach &#123; v =&gt;</span><br><span class="line">      executorEnvs(<span class="string">"SPARK_PREPEND_CLASSES"</span>) = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The Mesos scheduler backend relies on this environment variable to set executor memory.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Set this only in the Mesos scheduler.</span></span><br><span class="line">    executorEnvs(<span class="string">"SPARK_EXECUTOR_MEMORY"</span>) = executorMemory + <span class="string">"m"</span></span><br><span class="line">    executorEnvs ++= _conf.getExecutorEnv</span><br><span class="line">    executorEnvs(<span class="string">"SPARK_USER"</span>) = sparkUser</span><br></pre></td></tr></table></figure></li><li><p>创建心跳检测器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need to register "HeartbeatReceiver" before "createTaskScheduler" because Executor will</span></span><br><span class="line">    <span class="comment">// retrieve "HeartbeatReceiver" in the constructor. (SPARK-6640)</span></span><br><span class="line">    _heartbeatReceiver = env.rpcEnv.setupEndpoint(</span><br><span class="line">      <span class="type">HeartbeatReceiver</span>.<span class="type">ENDPOINT_NAME</span>, <span class="keyword">new</span> <span class="type">HeartbeatReceiver</span>(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure></li><li><p>创建DAGScheduler和TaskScheduler</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and start the scheduler</span></span><br><span class="line">    <span class="keyword">val</span> (sched, ts) = <span class="type">SparkContext</span>.createTaskScheduler(<span class="keyword">this</span>, master, deployMode)</span><br><span class="line">    _schedulerBackend = sched</span><br><span class="line">    _taskScheduler = ts</span><br><span class="line">    _dagScheduler = <span class="keyword">new</span> <span class="type">DAGScheduler</span>(<span class="keyword">this</span>)</span><br><span class="line">    _heartbeatReceiver.ask[<span class="type">Boolean</span>](<span class="type">TaskSchedulerIsSet</span>)</span><br></pre></td></tr></table></figure></li><li><p>启动TaskScheduler</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start TaskScheduler after taskScheduler sets DAGScheduler reference in DAGScheduler's</span></span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    _taskScheduler.start()</span><br></pre></td></tr></table></figure></li><li><p>启动metricSystem给Spark Application id 赋值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The metrics system for Driver need to be set spark.app.id to app ID.</span></span><br><span class="line">    <span class="comment">// So it should start after we get app ID from the task scheduler and set spark.app.id.</span></span><br><span class="line">    _env.metricsSystem.start()</span><br><span class="line">    <span class="comment">// Attach the driver metrics servlet handler to the web ui after the metrics system is started.</span></span><br><span class="line">    _env.metricsSystem.getServletHandlers.foreach(handler =&gt; ui.foreach(_.attachHandler(handler)))</span><br></pre></td></tr></table></figure></li><li><p>调用一下三个方法，创建SparkContext</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setupAndStartListenerBus()</span><br><span class="line">  postEnvironmentUpdate()</span><br><span class="line">  postApplicationStart()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SparkCore之SparkContext-SparkConf&quot;&gt;&lt;a href=&quot;#SparkCore之SparkContext-SparkConf&quot; class=&quot;headerlink&quot; title=&quot;SparkCore之SparkContext,SparkConf&quot;&gt;&lt;/a&gt;SparkCore之SparkContext,SparkConf&lt;/h1&gt;&lt;p&gt;本文记录SparkCore,SparkContext,SparkConf源码阅读笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spark" scheme="https://thisiswilli.cn/categories/Spark/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中变量的线程安全分析</title>
    <link href="https://thisiswilli.cn/2020/03/14/Java%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/"/>
    <id>https://thisiswilli.cn/2020/03/14/Java%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</id>
    <published>2020-03-14T13:39:32.000Z</published>
    <updated>2020-03-14T13:41:01.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h1><p>本文分析对Java程序中的变量是否安全进行分析</p><a id="more"></a><h2 id="成员变量和静态变量是否线程安全"><a href="#成员变量和静态变量是否线程安全" class="headerlink" title="成员变量和静态变量是否线程安全"></a>成员变量和静态变量是否线程安全</h2><ul><li>如果它们没有共享，则是线程安全的</li><li>若它们被共享了，根据它们的状态是否能够改变，分成两种情况<ul><li>若只是读操作，则线程安全</li><li>若是读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h2 id="局部变量是否线程安全"><a href="#局部变量是否线程安全" class="headerlink" title="局部变量是否线程安全"></a>局部变量是否线程安全</h2><ul><li>局部变量是线程安全的</li><li>但是有一种情况需要注意，当局部变量引用是对象时<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该该对象逃离了方法的作用范围，则需要考虑线程安全</li></ul></li></ul><h2 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h2><h3 id="局部变量是基本类型或者包装类型"><a href="#局部变量是基本类型或者包装类型" class="headerlink" title="局部变量是基本类型或者包装类型"></a>局部变量是基本类型或者包装类型</h3><p>如果局部变量是基本类型或者包装类型，那么局部变量是线程安全的，如下代码所示，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariableTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test1();</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test1();</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程在执行test1方法是，都会在自己的栈帧中创建一份局部变量i的副本，两个线程的i互不影响，所以是线程安全的</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%88%86%E5%88%AB%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E6%A0%88%E5%B8%A7.png" style="zoom:50%;" /><h3 id="局部变量引用的是一个对象，但是没有暴露给外部"><a href="#局部变量引用的是一个对象，但是没有暴露给外部" class="headerlink" title="局部变量引用的是一个对象，但是没有暴露给外部"></a>局部变量引用的是一个对象，但是没有暴露给外部</h3><p>​        如果局部变量引用的是一个对象，但是这个对象没有暴露给外部，那么还是线程安全的，如下代码所示，两个线程分别调用method1方法，但是每个线程维护着自己的栈，会在自己的栈中创建一个ArrayList，两个线程互不影响，不会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariableTest3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOP_NUM = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSafe test = <span class="keyword">new</span> ThreadSafe();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                test.method1(LOOP_NUM);</span><br><span class="line">            &#125;, <span class="string">"Thread"</span> + i + <span class="number">1</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++)&#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量引用的是一个对象，但是这个对象暴露给了外部线程"><a href="#局部变量引用的是一个对象，但是这个对象暴露给了外部线程" class="headerlink" title="局部变量引用的是一个对象，但是这个对象暴露给了外部线程"></a>局部变量引用的是一个对象，但是这个对象暴露给了外部线程</h3><p>​        当局部变量引用的是一个对象，当一个线程在自己的栈中创建了这个对象的副本后，如果一直是这个线程对这个对象进行操作，不会发生，但是，当把这个对象暴露给外部，让别的线程也能来操作它，那么就会出现问题，</p><p>​        如下代码所示，如果用一个子类继承ThreadSafe并重写了移除元素的方法，重新创建一个线程来移除list中的元素，那么，原来是t1,t2分别执行method1方法，两个线程在自己维护的栈中分别创建了一个list，但是执行method3时，新创建出来的线程会对两个线程中的list进行操作，<strong>相当于两个线程同时对一个list进行操作，就产生了竟态条件</strong>，如果不加锁，就会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariableTest3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOP_NUM = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ThreadSafe test = new ThreadSafe();</span></span><br><span class="line">        ThreadSafeSubClass test = <span class="keyword">new</span> ThreadSafeSubClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                test.method1(LOOP_NUM);</span><br><span class="line">            &#125;, <span class="string">"Thread"</span> + i + <span class="number">1</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++)&#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码，会报如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-399&quot; java.lang.IndexOutOfBoundsException: Index: 0, Size: 0</span><br><span class="line">at java.util.ArrayList.rangeCheck(ArrayList.java:657)</span><br><span class="line">at java.util.ArrayList.remove(ArrayList.java:496)</span><br><span class="line">at com.concurrency.synchronizedstudy.ThreadSafeSubClass.lambda$method3$0(LocalVariableTest3.java:49)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;变量的线程安全分析&quot;&gt;&lt;a href=&quot;#变量的线程安全分析&quot; class=&quot;headerlink&quot; title=&quot;变量的线程安全分析&quot;&gt;&lt;/a&gt;变量的线程安全分析&lt;/h1&gt;&lt;p&gt;本文分析对Java程序中的变量是否安全进行分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Thread对象中的方法和属性</title>
    <link href="https://thisiswilli.cn/2020/03/13/Thread%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>https://thisiswilli.cn/2020/03/13/Thread%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</id>
    <published>2020-03-13T08:55:37.000Z</published>
    <updated>2020-03-13T09:00:25.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread对象中的方法和属性"><a href="#Thread对象中的方法和属性" class="headerlink" title="Thread对象中的方法和属性"></a>Thread对象中的方法和属性</h1><p>本文对java.lang包中的Thread类中的部分方法及属性进行介绍</p><a id="more"></a><h2 id="start和run方法"><a href="#start和run方法" class="headerlink" title="start和run方法"></a>start和run方法</h2><ul><li>start，是让线程启动的方法，start方法是不能重复多次调用的，多次调用会报错</li><li>run，是线程启动之后执行的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAndRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is running.."</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        上面的代码，如果调用的run()那么打印输出的会是主线程，如果调用的是start()方法，那么打印输出的会是新创建的Thread线程。</p><h2 id="sleep和yield方法"><a href="#sleep和yield方法" class="headerlink" title="sleep和yield方法"></a>sleep和yield方法</h2><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><ul><li>会让当前线程从running状态切换到time waiting状态</li><li>其他线程可以使用interrupt方法打断正在睡眠的线程，此时睡眠线程会抛出异常</li><li>睡眠结束后的线程未必立即执行，因为有可能cpu还在执行别的线程，没有时间片分给它</li><li>建议使用TimeUnit的sleep</li><li>sleep不会释放锁</li></ul><p>执行一下代码，线程t1被主线程打断之后，会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"is sleeping"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"is interrupted"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1is sleeping</span><br><span class="line">t1is interrupted</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">at com.concurrency.threadstructure.ThreadSleep.lambda$main$0(ThreadSleep.java:17)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>会让当前线程从running切换到runnable就绪状态，也就是先将时间片让给别的线程，然后调用其他同优先级的线程，如果这时没有同优先级的线程，那么不能保证让当前线程暂停的效果</li><li>具体实现依赖操作系统的线程调度器，会出现想让没有让出去的现象，也就是时间片资源较为丰富，该线程即使一直执行yield方法让出时间片，但是调度器还是会分配空闲的时间片让它执行</li></ul><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ul><li><strong>调用了yield的线程还有可能继续运行</strong>，但是调用了sleep方法的线程不可能继续运行，因为cpu不会分配时间片给time waiting状态的线程</li><li>sleep可以指定时间，yield只是存粹调用</li></ul><h2 id="线程优先级-setPriority"><a href="#线程优先级-setPriority" class="headerlink" title="线程优先级-setPriority()"></a>线程优先级-setPriority()</h2><ul><li><p>线程优先级会提示系统线程调度器优先调度该线程，但是它仅仅是一个提示，线程调度器可以忽视它</p></li><li><p>如果cpu较忙，优先级较高的线程会获得较多的时间片，cpu不忙时，线程优先级几乎没有作用</p><p>​    下列代码可显著看出在t2线程一直调用yield方法时，t1线程打印的次数会明显增多，调整每个线程的优先级也会影响打印次数。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                System.out.println(<span class="string">"----&gt;1"</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                System.out.println(<span class="string">"      ----&gt;2"</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>​        如果一个线程中对另一个Thread对象调用了join方法，那么这个线程必须要等那个Thread对象执行完毕之后，才能继续执行。</p><h2 id="线程的同步和异步"><a href="#线程的同步和异步" class="headerlink" title="线程的同步和异步"></a>线程的同步和异步</h2><p>以调用方法的角度来理解：</p><ul><li>两个线程在运行时，如果一个线程需要等待另一个线程完成之后才能继续运行，那么这种情况叫做同步。</li><li>两个线程在运行时，一个线程不需要关系另一个线程的运行状态，那么这种情况叫做异步。</li></ul><h2 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h2><ul><li><p>用interrupt方法来打断阻塞状态的线程，一般指调用了sleep， wait， join等方法的线程，</p><p>​        如果正在执行这些方法的线程被打断，那么其isInterrupted()这个线程会抛出异常，但是它会将isInterrupted()这个方法的执行结果置为false，这很奇怪，如果我们获取这个线程是否被打断的结果，我们会得到false，这会影响到我们后续判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterrupt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">      <span class="comment">// 主线程先睡500ms</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">      <span class="comment">// 主线程打断t1线程</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">at com.concurrency.threadstructure.ThreadInterrupt.lambda$main$0(ThreadInterrupt.java:16)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></li><li><p>如果我们用interrupt方法打断的是正在运行的线程，</p><p>​        如下所示，主线程调用了interrupt之后，t1不会被立刻打断，<strong>相当于t1只是被告知主线程想要打断你</strong>，t1需要自行判断是否被打断，若打断，可以执行一些措施之后，比如释放锁，在让线程终止，这样更加安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterrupt2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"被打断了"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1被打断了</span><br></pre></td></tr></table></figure><h2 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h2><p>都可能造成锁资源无法释放，不推荐使用</p><ul><li>stop()</li><li>suspend()</li><li>resume()</li></ul><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>​        默认情况下，Java进程需要等待所有线程都运行结束，才会结束，有一种特殊的线程叫做守护线程，<strong>只要其他非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束</strong>。</p><p>​        如下代码所示，执行如下代码，主线程在执行完之后，daemon线程依然会继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread daemon = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"daemon"</span>);</span><br><span class="line">        daemon.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若将daemon线程设置为守护线程，当主线程结束后，java程序停止运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread daemon = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"daemon"</span>);</span><br><span class="line">        daemon.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        daemon.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>守护线程的应用场景</p><ul><li>垃圾回收线程就是一种守护线程</li><li>Tomcat中的Acceptor和Poller线程也是守护线程</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Thread对象中的方法和属性&quot;&gt;&lt;a href=&quot;#Thread对象中的方法和属性&quot; class=&quot;headerlink&quot; title=&quot;Thread对象中的方法和属性&quot;&gt;&lt;/a&gt;Thread对象中的方法和属性&lt;/h1&gt;&lt;p&gt;本文对java.lang包中的Thread类中的部分方法及属性进行介绍&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://thisiswilli.cn/2020/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://thisiswilli.cn/2020/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-10T11:18:28.000Z</published>
    <updated>2020-04-23T11:22:56.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>​        本文介绍设计模式中的单例模式</p><a id="more"></a><p>​        在单例模式使得一个类的对象成为该类所在系统的唯一实例，单例模式适合用于需要重复创建的类，比如配置文件类。单例模式能够减少系统内存开销，降低GC压力。</p><h3 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式有以下几点特点</p><ul><li>在类加载时就创建对象，即在类中将对象定义成static类型的类变量，跟随类一起加载，这种方式类似于<strong>空间换时间</strong></li><li>将构造器私有，让别的类不能创建对象</li><li>提供一个全局访问点，即提供一个public的以类自身为返回值的方法</li><li><strong>懒汉式是线程安全的</strong></li></ul><p>代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungryMode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在类加载时直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungryMode hungryMode = <span class="keyword">new</span> HungryMode();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungryMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungryMode <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungryMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hungry mode"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HungryMode.getInstance().say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>懒汉式具有以下几个特点</p><ul><li>懒汉式在第一次使用时才进行加载，这样在起初能够减少内存的占用，但是会导致第一次使用类时加载速度较慢</li><li>懒汉模式是以时间换空间</li><li>懒汉模式存在线程不安全的风险</li></ul><p>代码实现</p><h5 id="不考虑线程安全的简单实现"><a href="#不考虑线程安全的简单实现" class="headerlink" title="不考虑线程安全的简单实现"></a>不考虑线程安全的简单实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMode lazyMode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMode</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyMode <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazyMode = <span class="keyword">new</span> LazyMode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加一把锁"><a href="#加一把锁" class="headerlink" title="加一把锁"></a>加一把锁</h5><p>​        上面这种情况，如果多线程访问，可能会导致重复创建对象的情况出现，针对这种情况，可以在getInstance方法上加一把锁，这种方式实现很简单，但是每次调用getIntance方法拿到实例对象时，都需要拿到锁，可能会造成线程阻塞的情况出现，效率不高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModeSingleLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyModeSingleLock lazyModeSingleLock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyModeSingleLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  LazyModeSingleLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyModeSingleLock == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazyModeSingleLock = <span class="keyword">new</span> LazyModeSingleLock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyModeSingleLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加两把锁"><a href="#加两把锁" class="headerlink" title="加两把锁"></a>加两把锁</h5><p>解释一下为什么需要使用volatile修饰LazyModeDCL实例</p><ul><li><p>防止指令重排序</p><p>创建一个对象是一个非原子操作，创建一个对象分为一下几个步骤</p><ul><li>开辟内存空间–a</li><li>调用构造器创建对象–b</li><li>返回地址给对象引用–c</li></ul><p>​      指令重排序之后可能会出现a-&gt;c-&gt;b的执行顺序，<strong>而synchronized只能保护代码块中的lazyModeDCL的原子性，而if判断语句在monitor的控制之外，别的线程可以越过monitor执行if语句读取lazyModeDCL这个变量</strong>，假设线程一拿到了锁，并执行了指令重排序后的代码，线程二在线程一运行的过程中可以执行if语句，虽然lazyModeDCL不为空，但是这是一个还没初始化完的对象，线程二可能直接返回一个没有创建完的对象，这也是我们不希望看到的，<strong>所以synchronized只保证了代码的有序性，但是变量的赋值操作依旧可以被编译器优化，此时会发生指令重排序</strong>，所以必须要加入volatile来保证代码不会被指令重排序，或者像第一种方法一样，直接用synchronized修饰方法，这样即使被指令重排序，但是别的线程还是不能去执行if语句，还是线程安全的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModeDCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyModeDCL lazyModeDCL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyModeDCL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyModeDCL <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyModeDCL == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyModeDCL<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyModeDCL == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyModeDCL = <span class="keyword">new</span> LazyModeDCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyModeDCL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用静态内部类"><a href="#使用静态内部类" class="headerlink" title="使用静态内部类"></a>使用静态内部类</h5><p>静态内部类的加载机制属于被动引用的行列，即在外部类初始化时，静态内部类如果没有被使用，就不会主动加载，静态内部类的方式类似于饿汉模式，也是线程安全的，但是使用这种方式将无法传参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModeStaticClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyModeStaticClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">setInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> LazyModeStaticClass INSTANCE = <span class="keyword">new</span> LazyModeStaticClass();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyModeStaticClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> setInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingle &#123;</span><br><span class="line">    <span class="comment">// INSTANCE;</span></span><br><span class="line">  EnumSingle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(EnumSingle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;p&gt;​        本文介绍设计模式中的单例模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://thisiswilli.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://thisiswilli.cn/tags/Java/"/>
    
      <category term="设计模式" scheme="https://thisiswilli.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式和抽象工厂模式</title>
    <link href="https://thisiswilli.cn/2020/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://thisiswilli.cn/2020/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-09T14:32:44.000Z</published>
    <updated>2020-04-23T11:22:22.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>​        本文介绍设计模式中的工厂模式</p><a id="more"></a><p>​        工厂模式在设计模式中属于创建者模式，工厂模式的目的是不让创建对象时不把创建逻辑暴露给客户端，并且通过一个统一接口来指向创建对象</p><h3 id="核心本质"><a href="#核心本质" class="headerlink" title="核心本质"></a>核心本质</h3><ul><li><strong>实例化对象不是用new而使用工厂方法代替</strong></li><li>将选择实现类，创建对象统一管理和控制，从而将调用者与使用者解耦</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>​        简单工厂模式又称静态工厂模式，简单工厂创建一个工厂类，根据客户端传入的不同参数，来创建不同的产品(类)。而这些被创建的类都实现同一个接口。简单工厂模式适合在产品类较少的环境下使用，因为这样能够避免工厂类中的代码逻辑过于复杂。</p><h4 id="简单工厂所包含的角色"><a href="#简单工厂所包含的角色" class="headerlink" title="简单工厂所包含的角色"></a>简单工厂所包含的角色</h4><ul><li>产品接口：担任简单工厂所创建产品的父类，用interface实现</li><li>产品类：简单工厂所创建的产品实例，都实现了产品接口</li><li>工厂类：核心类，包含着产品类的创建逻辑，客户端直接与工厂类交互来获得新产品</li></ul><h4 id="简单工厂的优缺点"><a href="#简单工厂的优缺点" class="headerlink" title="简单工厂的优缺点"></a>简单工厂的优缺点</h4><p>优点：</p><ul><li>工厂类能够使产品的创建与产品的消费实现解耦，让客户端不需要了解产品是怎么创建的，只需负责消费即可，如果没有工厂类，那么客户端在获取一个产品类的时候就要先去创建产品，客户端同时负责创建和消费产品，这样代码之间过于耦合。</li><li>客户端不用掌握产品类的具体信息，只要根据一些必要参数，就能让工厂类完成所需类的创建</li><li>在工厂模式下，产品的添加与删除都不用修改客户端的代码，提高了系统的灵活性</li></ul><p>缺点：</p><ul><li>系统扩展较为复杂，如果需要添加一个新的产品，就需新创建一个产品类，并需要更改工厂类中的代码，如果产品很多，会使得工厂类中的代码逻辑较为复杂，难以维护</li></ul><h4 id="简单工厂的实现"><a href="#简单工厂的实现" class="headerlink" title="简单工厂的实现"></a>简单工厂的实现</h4><p>uml图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%9B%BE.png" alt=""></p><ul><li><p>首先创建一个车的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建两个产品类，并实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"特斯拉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLing</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"五菱宏光"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建工厂类，并用静态方法完成对产品类的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Car <span class="title">buyCar</span><span class="params">(String car)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (car.equals(<span class="string">"WuLing"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WuLing();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (car.equals(<span class="string">"Tesla"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消费者，如下代码所示，消费者如果要购买Tesla，他不需要了解Tesla的具体信息，只需要创建一个工厂，并告诉工厂，他需要购买一辆特斯拉，也就是传入Tesla字符串，就能得到一个Tesla实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car tesla = <span class="keyword">new</span> CarFactory().buyCar(<span class="string">"Tesla"</span>);</span><br><span class="line">        tesla.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>​        在工厂模式下，每一样产品都有自己对应的生产工厂，客户端只需要知道所需产品的工厂名称，即可通过创建工厂来获得产品</p><h4 id="工厂模式的角色"><a href="#工厂模式的角色" class="headerlink" title="工厂模式的角色"></a>工厂模式的角色</h4><ul><li>工厂接口：每个产品工厂的父类，定义每个产品工厂的功能</li><li>子类工厂：每个产品所对应的工厂，负责生产对应的产品</li><li>产品类</li></ul><h4 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h4><p>优点：</p><ul><li>客户端不需要知道类的具体信息，只需要知道类对应的工厂，然后创建该工厂，就能获得产品</li><li>扩展性好，新添加一样产品，只需新创建一个该产品的工厂类即可。</li><li>屏蔽产品的具体实现，客户端只关心产品的接口。</li></ul><p>缺点</p><ul><li>如果添加的产品过多，可能会使类的个数成倍增长，增加了系统的复杂度</li></ul><h4 id="工厂模式的实现"><a href="#工厂模式的实现" class="headerlink" title="工厂模式的实现"></a>工厂模式的实现</h4><p>uml图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8Fuml%E5%9B%BE.png" alt=""></p><ul><li><p>创建实体类的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"特斯拉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLing</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"五菱宏光"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建工厂类的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建每个床品对应的工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeslaCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLingFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WuLing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消费者来消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car wuling = <span class="keyword">new</span> WuLingFactory().getCar();</span><br><span class="line">        Car tesla = <span class="keyword">new</span> TeslaCarFactory().getCar();</span><br><span class="line">        wuling.name();</span><br><span class="line">        tesla.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="抽像工厂模式"><a href="#抽像工厂模式" class="headerlink" title="抽像工厂模式"></a>抽像工厂模式</h3><p>​        在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h4 id="抽象工厂的角色"><a href="#抽象工厂的角色" class="headerlink" title="抽象工厂的角色"></a>抽象工厂的角色</h4><ul><li>超级工厂：所有工厂的抽象化实现，超级工厂生产抽象的产品，具体产品的生产交给子类去做</li><li>产品的抽象类</li><li>工厂类</li><li>产品类</li></ul><h4 id="抽象工厂的优缺点"><a href="#抽象工厂的优缺点" class="headerlink" title="抽象工厂的优缺点"></a>抽象工厂的优缺点</h4><p>优点：</p><ul><li>客户端不需要知道什么被生产了，只需接受生产类给他生产的产品</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的工厂和产品族很方便，无需修改已有系统，符合开闭原则，比如下面实现的例子，如果我要加一个苹果工厂的实例，只需要增加一个苹果工厂并实现超级工厂这个接口即可</li></ul><p>缺点：</p><ul><li>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，比如下面如果需要增加一个手表类，那么原来的代码很多地方都要修改。</li></ul><h4 id="抽象工厂的实现"><a href="#抽象工厂的实现" class="headerlink" title="抽象工厂的实现"></a>抽象工厂的实现</h4><p>uml图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82uml.png" alt=""></p><ul><li><p>首相创建两个抽象的产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RouteProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建两个抽象产品相应的产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title">PhoneProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiRoute</span> <span class="keyword">implements</span> <span class="title">RouteProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei route send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei route receive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiRoute</span> <span class="keyword">implements</span> <span class="title">RouteProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi route send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi route receive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建超级工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">RouteProduct <span class="title">routeProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建每个产品对应的工厂类，超级工厂的子类负责创建产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteProduct <span class="title">routeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiRoute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteProduct <span class="title">routeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiRoute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消费者去消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HuaweiFactory huaweiFactory = <span class="keyword">new</span> HuaweiFactory();</span><br><span class="line">        PhoneProduct huaweiPhone = huaweiFactory.phoneProduct();</span><br><span class="line">        huaweiPhone.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;​        本文介绍设计模式中的工厂模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://thisiswilli.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://thisiswilli.cn/tags/Java/"/>
    
      <category term="设计模式" scheme="https://thisiswilli.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之ThreadPool简介</title>
    <link href="https://thisiswilli.cn/2020/03/03/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadPool%E7%AE%80%E4%BB%8B/"/>
    <id>https://thisiswilli.cn/2020/03/03/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadPool%E7%AE%80%E4%BB%8B/</id>
    <published>2020-03-03T12:04:44.000Z</published>
    <updated>2020-04-23T11:21:49.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><p>本文介绍Java中的ThreadPool</p><a id="more"></a><h2 id="需要了解的相关接口或类"><a href="#需要了解的相关接口或类" class="headerlink" title="需要了解的相关接口或类"></a>需要了解的相关接口或类</h2><p>首先，ThreadPool有关的接口或类的继承图如下</p><p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/threadpool_9.png" alt=""></p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>顶级接口，调用实现了Runnable接口的命令</p><p>Executors的存在是为了避免开发者显式的去创建一个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor是一个线程框架</p><p>简单实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyExecutor().execute(()-&gt;&#123;</span><br><span class="line">          <span class="comment">// 实现了run方法</span></span><br><span class="line">            System.out.println(<span class="string">"hello command"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新起一个线程去调用这个方法</span></span><br><span class="line"><span class="comment">//        new Thread(command).run();</span></span><br><span class="line">        <span class="comment">// 调用run方法</span></span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><pre><code>该接口继承自Executor接口，扩展了Executor接口，添加了shutdown、shutdownAll、submit、invokeAll等一系列对线程的操作方法，该接口比较重要，在使用线程池框架的时候，经常用到该接口。</code></pre><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>线程池的工厂类，用工厂方法初始化各种线程池，一下为部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="meta">@param</span> nThreads the number of threads in the pool</span><br><span class="line"> * <span class="meta">@return</span> the newly created thread pool</span><br><span class="line"> * <span class="meta">@throws</span> IllegalArgumentException <span class="keyword">if</span> &#123;<span class="meta">@code</span> nThreads &lt;= <span class="number">0</span>&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* creates a <span class="keyword">new</span> thread</span><br><span class="line"> * <span class="meta">@return</span> a newly created scheduled thread pool</span><br><span class="line"> * <span class="meta">@throws</span> IllegalArgumentException <span class="keyword">if</span> &#123;<span class="meta">@code</span> corePoolSize &lt; <span class="number">0</span>&#125;</span><br><span class="line"> * <span class="meta">@throws</span> NullPointerException <span class="keyword">if</span> threadFactory is <span class="keyword">null</span></span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><pre><code>Callable接口与Runnable接口类似，实现了Callable接口与Runnable接口的类都是可以被其他线程执行的任务。但是Callable与Runnable有几点不同：</code></pre><ul><li>Callable规定的方法是call()，而Runnable规定的方法是run()。</li><li>Callable的任务执行后可返回值，  运行Callable的方法可返回一个Future对象，Future表示这个线程的执行结果。而Runnable的任务是不能返回值的。</li><li>call()方法可抛出异常，而run()方法是不能抛出异常的。</li></ul><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>future接口中有3个方法，2个属性</p><ul><li><p><code>boolean cancel(boolean mayInterruptIfRunning);</code></p><p>该方法用于取消任务的执行</p></li><li><p><code>boolean isCancelled();</code></p><p>判断任务在完成之前被停止</p></li><li><p><code>boolean isDone()</code></p><p>无论是如果任务正常终止、异常或取消，都将返回true</p></li><li><p><code>V get() throws InterruptedException, ExecutionException</code></p><p>等待任务结束，并获取任务结束的返回值</p></li><li><p><code>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;</code></p><p>等待任务结束，在timeout的时间内获取任务的返回值，如果超时则不再等待</p></li></ul><h2 id="多种线程池"><a href="#多种线程池" class="headerlink" title="多种线程池"></a>多种线程池</h2><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>容量大小固定的线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将主线程阻塞</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为，可见线程池最大容量为5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Running, pool size &#x3D; 0, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 0]</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-5</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-5</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Running, pool size &#x3D; 5, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 10]</span><br></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>可缓存的线程池，来一个任务就创建一个线程，工作线程如果空闲超过一定时间，会被回收。默认为60s，以下为Executors工厂类中关于newCachedThreadPool()创建方式以及ThreadPoolExecutors构造器的源码，可见线程空闲时间超过60s，就会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来用代码进行测试，编写如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="comment">// 线程会被回收</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">70</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size &#x3D; 0, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 0]</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size &#x3D; 2, active threads &#x3D; 2, queued tasks &#x3D; 0, completed tasks &#x3D; 0]</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-1</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size &#x3D; 0, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 2]</span><br></pre></td></tr></table></figure><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>这个线程池容量为1，没轮到的工作在队列中等待，如果有任务需要从前往后顺序执行，可以使用SingleThreadExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 任务如果是前后顺序执行的，那么选择SingleThreadPool</span></span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executors$FinalizableDelegatedExecutorService@1d44bcfa</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">java.util.concurrent.Executors$FinalizableDelegatedExecutorService@1d44bcfa</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>定时器线程，线程可以复用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 定时器线程池，线程可以服用，以固定频率执行一个任务</span></span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">        service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">java.util.concurrent.ScheduledThreadPoolExecutor@3feba861[Running, pool size &#x3D; 4, active threads &#x3D; 0, queued tasks &#x3D; 1, completed tasks &#x3D; 7]</span><br></pre></td></tr></table></figure><h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p>工作窃取线程池，如果10个任务由4个线程来完成，那么并不一定4个线程都会被均匀分配任务，这就意味着，如果线程1忙完了那么他就可能会抢在剩下3个线程之前去接着执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkingStealingPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务分配不均匀的场景</span></span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">R</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newWorkStealingPool(<span class="number">4</span>);</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1处理的任务时间比任务2长</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">3000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">1000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">4000</span>));</span><br><span class="line">        <span class="comment">// 等4个线程都分配到任务执行之后，线程2最先完成任务，并抢占剩下的任务去执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">5000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">6000</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，可见线程2最先完成任务，并抢占剩下的任务执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br></pre></td></tr></table></figure><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><pre><code>ForkJoinPool任务的执行逻辑有点类似于排序中的归并排序，以及大数据处理中的mapreduce的过程，ForkJoinPool的运行逻辑图如下所示</code></pre><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/ForkJoin%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h4 id="ForkJoinPool中的模块"><a href="#ForkJoinPool中的模块" class="headerlink" title="ForkJoinPool中的模块"></a>ForkJoinPool中的模块</h4><ul><li><p>任务对象ForkJoinTask，这是一个抽象类，在实际使用中，我们一般使用它的子类来创建ForkJoinPool的任务对象</p><ul><li><p>RecursiveTask，重写该类中的compute方法，自定义所需的task任务，该task任务可以返回task的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the result of the computation</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">compute</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>RecursiveAction，与RecursiveTask类似，但是RecursiveAction中的compute方法不带返回值，不能返回task的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>执行Fork/Join任务的线程: <code>ForkJoinWorkerThread</code>，这个类中维护着一个任务队列workQueue，工作线程优先处理来自自身队列的任务(LIFO或FIFO顺序，参数 mode 决定)，然后以FIFO的顺序随机窃取其他队列中的任务，这跟WorkStealingPool原理是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a ForkJoinWorkerThread operating in the given pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pool the pool this thread works in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if pool is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">        <span class="keyword">this</span>.pool = pool;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Version for InnocuousForkJoinWorkerThread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ForkJoinWorkerThread(ForkJoinPool pool, ThreadGroup threadGroup,</span><br><span class="line">                         AccessControlContext acc) &#123;</span><br><span class="line">        <span class="keyword">super</span>(threadGroup, <span class="keyword">null</span>, <span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, INHERITEDACCESSCONTROLCONTEXT, acc);</span><br><span class="line">        eraseThreadLocals(); <span class="comment">// clear before registering</span></span><br><span class="line">        <span class="keyword">this</span>.pool = pool;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>线程池: <code>ForkJoinPool</code>，线程池维护着管理所有的<code>ForkJoinWorkerThread</code></li></ul><h4 id="ForkJoinPool的应用"><a href="#ForkJoinPool的应用" class="headerlink" title="ForkJoinPool的应用"></a>ForkJoinPool的应用</h4><p>使用计算40000个随机数为例，来演示ForkJoinPool的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"单线程计算数组和为"</span> + Arrays.stream(nums).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask1</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTask1</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start &lt;= MAX_NUM)&#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"from "</span> + start + <span class="string">"to "</span> + end + <span class="string">"="</span> + sum);</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">                AddTask1 subTask1 = <span class="keyword">new</span> AddTask1(start, mid);</span><br><span class="line">                AddTask1 subTask2 = <span class="keyword">new</span> AddTask1(mid, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask1 task1 = <span class="keyword">new</span> AddTask1(<span class="number">0</span>, nums.length);</span><br><span class="line">        pool.execute(task1);</span><br><span class="line">        Long result = task1.join();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">单线程计算数组和为49475235</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">多线程计算数组和为49475235</span><br></pre></td></tr></table></figure><h2 id="线程池的应用"><a href="#线程池的应用" class="headerlink" title="线程池的应用"></a>线程池的应用</h2><h3 id="利用线程池进行并行计算"><a href="#利用线程池进行并行计算" class="headerlink" title="利用线程池进行并行计算"></a>利用线程池进行并行计算</h3><pre><code>以计算1～400000这几个数中的质数个数为例，分别用单线程和多线程进行计算，比较执行任务的时间为了在每个线程执行完毕之后获得运行结果，我们需要使用submit()方法提交任务，通过返回的Future来获取每个list的数据或者大小</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelCompute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        List&lt;Integer&gt; result = getPrime(<span class="number">1</span>, <span class="number">4000000</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"单线程耗时"</span> + (end - start) + <span class="string">"ms "</span> + <span class="string">"质数个数为"</span> + result.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cpuCoreNum = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class="line"></span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f1 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">1</span>, <span class="number">1000000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f2 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">1000001</span>, <span class="number">2000000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f3 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">2000001</span>, <span class="number">3000000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f4 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">3000001</span>, <span class="number">4000000</span>));</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> size1 = f1.get().size();</span><br><span class="line">        <span class="keyword">int</span> size2 = f2.get().size();</span><br><span class="line">        <span class="keyword">int</span> size3 = f3.get().size();</span><br><span class="line">        <span class="keyword">int</span> size4 = f4.get().size();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"多线程耗时"</span> + (end - start) + <span class="string">"ms "</span> + <span class="string">"质数个数为"</span> + (size1 + size2 + size3 + size4));</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="comment">/*&lt;= num*/</span>&lt;= Math.sqrt(num) + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startPos, endPos;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> startPos, <span class="keyword">int</span> endPos)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = startPos;</span><br><span class="line">            <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; result = getPrime(startPos, endPos);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i))&#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单线程耗时3414ms 质数个数为2000000</span><br><span class="line">多线程耗时1133ms 质数个数为2000000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadPool&quot;&gt;&lt;a href=&quot;#ThreadPool&quot; class=&quot;headerlink&quot; title=&quot;ThreadPool&quot;&gt;&lt;/a&gt;ThreadPool&lt;/h1&gt;&lt;p&gt;本文介绍Java中的ThreadPool&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
