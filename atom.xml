<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ThisisWilli</title>
  
  <subtitle>Time is now</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thisiswilli.cn/"/>
  <updated>2020-03-19T11:25:47.022Z</updated>
  <id>https://thisiswilli.cn/</id>
  
  <author>
    <name>Willi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Synchronized关键字及进阶</title>
    <link href="https://thisiswilli.cn/2020/03/19/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E8%BF%9B%E9%98%B6/"/>
    <id>https://thisiswilli.cn/2020/03/19/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E8%BF%9B%E9%98%B6/</id>
    <published>2020-03-19T11:24:34.000Z</published>
    <updated>2020-03-19T11:25:47.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Synchronized关键字及进阶"><a href="#Synchronized关键字及进阶" class="headerlink" title="Synchronized关键字及进阶"></a>Synchronized关键字及进阶</h1><p>本文介绍synchronized的基本用法以及一些进阶知识</p><a id="more"></a><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><pre><code>在了解synchronized前，还要了解临界区的概念，在多个线程访问共享资源时，并对共享资源读写操作发生指令交错，就会出现问题，**一个代码块如果存在对共享资源的读写操作**，那么这块代码块就叫做临界区。</code></pre><h2 id="为什么需要synchronized"><a href="#为什么需要synchronized" class="headerlink" title="为什么需要synchronized"></a>为什么需要synchronized</h2><pre><code>synchronized可以通过**阻塞的手段**避免避免临界区代码的竟态条件发生，synchronized用对象锁保证了临界区代码的原子性，临界区的代码对外是不可分割的，不会被其他线程所打断。</code></pre><h2 id="Synchronized用法简介"><a href="#Synchronized用法简介" class="headerlink" title="Synchronized用法简介"></a>Synchronized用法简介</h2><p>synchronized可以根据持有的锁分为持有对象锁和持有类锁两种情况</p><h3 id="持有对象锁"><a href="#持有对象锁" class="headerlink" title="持有对象锁"></a>持有对象锁</h3><p>当持有的是对象锁时可以通过用sychonized直接修饰方法或者修饰方法块，代码template如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于   锁住了this对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>所有线程公用一把锁时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="comment">// 用static修饰是为了让每个线程的锁都为同一个对象</span></span><br><span class="line">    <span class="keyword">static</span> ObjectLock objectLock = <span class="keyword">new</span> ObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"this是  "</span> + <span class="keyword">this</span>.getClass());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(objectLock).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>是  <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-0结束</span></span><br><span class="line"><span class="class"><span class="title">this</span>是  <span class="title">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-4结束</span></span><br><span class="line"><span class="class"><span class="title">this</span>是  <span class="title">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-3结束</span></span><br><span class="line"><span class="class"><span class="title">this</span>是  <span class="title">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-2结束</span></span><br><span class="line"><span class="class"><span class="title">this</span>是  <span class="title">class</span> <span class="title">com</span>.<span class="title">concurrency</span>.<span class="title">synchronizedstudy</span>.<span class="title">ObjectLock</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>-1结束</span></span><br></pre></td></tr></table></figure></li><li><p>自定义两把锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line">    <span class="comment">// 创建2把锁</span></span><br><span class="line">    Object block1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object block2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (block1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"block1锁,我是线程"</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"block1锁,"</span>+Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (block2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"block2锁,我是线程"</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"block2锁,"</span>+Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="持有类锁"><a href="#持有类锁" class="headerlink" title="持有类锁"></a>持有类锁</h3><p>持有类锁可以通过用synchronized修饰静态方法或者用synchronized代码块实现，代码template如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于   相当于锁住了类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span><span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现如下：</p><ul><li><p>代码块使用类锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 让每个线程的锁都为同一个对象</span></span><br><span class="line">    <span class="keyword">static</span> ObjectLock objectLock = <span class="keyword">new</span> ObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ObjectLock<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始沉睡"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(objectLock).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0开始沉睡</span><br><span class="line">Thread-0结束</span><br><span class="line">Thread-4开始沉睡</span><br><span class="line">Thread-4结束</span><br><span class="line">Thread-3开始沉睡</span><br><span class="line">Thread-3结束</span><br><span class="line">Thread-2开始沉睡</span><br><span class="line">Thread-2结束</span><br><span class="line">Thread-1开始沉睡</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure></li><li><p>用synchronized修饰静态方法使用类锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 让每个线程的锁都为同一个对象</span></span><br><span class="line">    <span class="keyword">static</span> ObjectLock objectLock = <span class="keyword">new</span> ObjectLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"在静态方法能使用类锁"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(objectLock).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0在静态方法内使用类锁</span><br><span class="line">Thread-0结束了</span><br><span class="line">Thread-4在静态方法内使用类锁</span><br><span class="line">Thread-4结束了</span><br><span class="line">Thread-3在静态方法内使用类锁</span><br><span class="line">Thread-3结束了</span><br><span class="line">Thread-2在静态方法内使用类锁</span><br><span class="line">Thread-2结束了</span><br><span class="line">Thread-1在静态方法内使用类锁</span><br><span class="line">Thread-1结束了</span><br></pre></td></tr></table></figure><p>也可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedStudy4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(Thread.currentThread().getName() + <span class="string">"在静态方法内使用类锁  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = SynchronizedStudy4::fun;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Synchronized关键字的特点"><a href="#Synchronized关键字的特点" class="headerlink" title="Synchronized关键字的特点"></a>Synchronized关键字的特点</h2><ul><li>Synchronized关键字不能被继承，子类如果要重写父类的synchronized方法，必须显示的加上sychronized关键字</li><li>一把锁只能被一个线程获取，没有获得锁的线程只能等待</li><li>每个实例都有自己的一把锁(this)，不同实例之间不回互相影响，锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁</li><li>synchronized修饰的方法无论是执行完毕还是抛出异常，都会释放锁</li><li>synchronized修饰的方法如果抛出异常是会释放锁的，很容易产生问题，多线程遇到异常时，要好好处理异常，可以在catch中进行回滚</li></ul><p>接下来从原理层面对synchronized关键字进行解析，首先要理解Java对象头的概念</p><h2 id="Java对象头的结构"><a href="#Java对象头的结构" class="headerlink" title="Java对象头的结构"></a>Java对象头的结构</h2><p>java的对象头有一下三部分组成：</p><ul><li><strong>Mark Word</strong></li><li>指向类的指针，即类型指针</li><li>数组长度(只有数组才有)</li></ul><p>java对象头的方式有以下两种，以32位JVM虚拟机为例</p><h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--------------------------------------------------------------|</span><br><span class="line">|                     Object Header (64 bits)                  |</span><br><span class="line">|------------------------------------|-------------------------|</span><br><span class="line">|        Mark Word (32 bits)         |    Klass Word (32 bits) |</span><br><span class="line">|------------------------------------|-------------------------|</span><br></pre></td></tr></table></figure><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------------------------------------------------------------|</span><br><span class="line">|                                 Object Header (96 bits)                         |</span><br><span class="line">|--------------------------------|-----------------------|------------------------|</span><br><span class="line">|        Mark Word(32bits)       |    Klass Word(32bits) |  array length(32bits)  |</span><br><span class="line">|--------------------------------|-----------------------|------------------------|</span><br></pre></td></tr></table></figure><h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p>这部分主要用来存储对象自身的运行时数据，如hashcode、gc分代年龄等。<code>mark word</code>的位长度为JVM的一个Word大小，也就是说32位JVM的<code>Mark word</code>为32位，64位JVM为64位。<br> 为了让一个字大小存储更多的信息，JVM将字的最低两个位设置为标记位，不同标记位下的Mark Word示意如下：</p><img src="https://img-blog.csdn.net/20180518151408659" style="zoom:60%;" /><h2 id="Monitor简介"><a href="#Monitor简介" class="headerlink" title="Monitor简介"></a>Monitor简介</h2><p>monitor被称为监视器或者管程</p><pre><code>每个Java对象都可以关联一个monitor对象，如果使用synchronized给对象上锁之后，该对象头的markword就被设置指向monitor对象的指针。</code></pre><h3 id="monitor工作原理"><a href="#monitor工作原理" class="headerlink" title="monitor工作原理"></a>monitor工作原理</h3><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/monitor.png" alt=""></p><p>注意</p><ul><li>synchronized必须是进入到<strong>同一个对象的monitor</strong>才有上述的效果</li><li>不加synchronized的对象不会关联监视器，不遵守以上规则</li></ul><h3 id="从字节码角度分析monitor"><a href="#从字节码角度分析monitor" class="headerlink" title="从字节码角度分析monitor"></a>从字节码角度分析monitor</h3><p>编写如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorByteCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将java文件编译成字节码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac MonitorByteCode.java</span><br></pre></td></tr></table></figure><p>反编译class文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c MonitorByteCode</span><br></pre></td></tr></table></figure><p>得到字节码，部分字节码如下所示， 考虑是否会出现异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  Code:</span><br><span class="line">     0: getstatic     #2                  &#x2F;&#x2F; lock引用  synchronized开始</span><br><span class="line">     3: dup&#x2F;&#x2F; 复制一份</span><br><span class="line">     4: astore_1&#x2F;&#x2F; 将lock引用存储到slot1中</span><br><span class="line">     5: monitorenter&#x2F;&#x2F; 将Lock对象中的MarkWord置为Monitor指针</span><br><span class="line">     6: getstatic     #3                  &#x2F;&#x2F; &lt;--i</span><br><span class="line">     9: iconst_1&#x2F;&#x2F; 准备常数i</span><br><span class="line">    10: iadd&#x2F;&#x2F; +1</span><br><span class="line">    11: putstatic     #3                  &#x2F;&#x2F; 将i赋值</span><br><span class="line">    14: aload_1&#x2F;&#x2F; 找到之前astore_1中存储的临时变量中的引用，通过其中的mark默认头找到monitor这个锁，</span><br><span class="line">    15: monitorexit&#x2F;&#x2F; 唤醒EntryList中等待的线程</span><br><span class="line">    16: goto          24</span><br><span class="line">    19: astore_2&#x2F;&#x2F; 将异常对象e-&gt;存储到slot2中</span><br><span class="line">    20: aload_1&#x2F;&#x2F; &lt;--lock引用</span><br><span class="line">    21: monitorexit&#x2F;&#x2F; 将Lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">    22: aload_2</span><br><span class="line">    23: athrow</span><br><span class="line">    24: return</span><br><span class="line">    &#x2F;&#x2F; 检查是否会出现异常</span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         6    16    19   any</span><br><span class="line">        19    22    19   any</span><br></pre></td></tr></table></figure><p>在没有别的线程竞争的情况下，优先使用的是轻量级锁</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><pre><code>轻量级锁使用场景：如果一个对象虽然有多线程访问，但是多线程访问的时间是错开的(也就是没有竞争)，那么可以使用轻量级锁来优化。**轻量级锁对使用者是透明的，是JVM层面的**，系统在运行时会先使用轻量级锁，如果轻量级锁不起作用，在使用重量级锁</code></pre><p>如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorByteCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建锁记录(Lock Record)对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%A0%88%E4%B8%AD%E5%88%9B%E5%BB%BALockRecord%E5%AF%B9%E8%B1%A1.png" style="zoom:50%;" /></li><li><p>让锁记录中的Object reference指向锁对象，并尝试用CAS替换Object中的Mark Word，将MarkWord中的值存入锁记录，其中Mark Word的值为00时，对应的是轻量级锁</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E6%9B%BF%E6%8D%A2%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%88%90%E5%8A%9F.png" style="zoom:50%;" /></li><li><p>如果CAS替换成功，锁对象的对象头中存储了锁记录地址和状态00，表示该线程给对象加锁</p></li><li><p>如果CAS失败，有两种情况</p><ul><li><p>如果其他线程持有了object的轻量级锁，这时表明有竞争，进入锁膨胀过程，锁膨胀过程后面解释</p></li><li><p>如果自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数，重入几次，就会有几个Lock Record，下图为重入的情况</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E9%94%81%E9%87%8D%E5%85%A5.png" style="zoom:50%;" /></li></ul></li><li><p>现在进入解锁过程，当退出synchronized代码块时(也就是解锁)如果有取值位null的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p></li><li><p>当退出synchronized代码块时，锁记录的值不为null，这时使用CAS将Mark Word的值恢复给对象头</p><ul><li><p>成功，则解锁成功</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E9%80%80%E5%87%BA%E5%B9%B6%E8%A7%A3%E9%94%81.png" style="zoom:50%;" /></li></ul></li></ul><ul><li>失败，说明轻量级锁进行了锁膨胀已经升级为重量级锁，进入重量级锁解锁流程</li></ul><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorByteCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是其他线程为此对象加上了轻量级锁(有竞争)，**这是需要进行锁膨胀，将轻量级锁变为重量级锁**</code></pre><ul><li><p>当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E9%94%81%E8%86%A8%E8%83%80.png" style="zoom:50%;" /></li><li><p>这是Thread-1加轻量级锁失败，进入锁膨胀流程</p><ul><li>即为加锁对象申请Monitor锁，让Object指向重量级锁地址，</li><li>然后自己进入Monitor的EntryList Blocked</li></ul><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E4%B8%BAObject%E5%AF%B9%E8%B1%A1%E7%94%B3%E8%AF%B7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.png" style="zoom:50%;" /></li><li><p>当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败，这是会进入重量级锁的解锁流程即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中的Blocked线程</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E8%A7%A3%E9%94%81.png" style="zoom:50%;" /></li></ul><h2 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h2><pre><code>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功(即当前持有锁的线程退出了同步块释放了锁)，这时当前线程就可以获得锁，避免阻塞，阻塞会发生上下文切换，耗费资源，**多核cpu下才有意义**</code></pre><ul><li>Java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功率会比较高，就多自旋几次，反之，就少自旋，甚至不自旋。</li><li>自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU才能发挥优势</li><li>Java7之后不能控制是否开启自旋功能</li></ul><h2 id="偏向锁优化"><a href="#偏向锁优化" class="headerlink" title="偏向锁优化"></a>偏向锁优化</h2><pre><code>**由于轻量级锁在没有竞争的情况下，重入时仍然要执行CAS操作**Java6中引入了偏向锁来做进一步优化：**只有第一次使用CAS将线程ID设置到锁对象的MarkWord头**，之后发现这个线程id是自己的就表示没有竞争，不用重新CAS，以后只要不发生竞争，这个对象就归该线程所有</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorByteCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">method3();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原先如果没有使用偏向锁，那么每次锁重入时，如下所示</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E5%8E%9F%E5%85%88%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" style="zoom:50%;" /><p>如果使用偏向锁优化，如下所示</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E5%81%8F%E5%90%91%E9%94%81%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E9%87%8D%E5%85%A5.png" style="zoom:50%;" /><h3 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h3><p>再看对象头</p><p><img src="https://img-blog.csdn.net/20180518151408659" alt=""></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁(默认开启)，那么对象创建之后，mark word的值为0x05，即对象头的后三位为101，但是线程ID，Epoch，分代年龄都为0</li><li>偏向锁默认是延迟的，如果想要程序启动就开启偏向锁，需要在VM参数中进行设置</li><li>如果没有开启偏向锁，那么对象创建后，markword值为0x01即最后三位为001，对应上图中的无锁状态</li></ul><p>根据场景决定是否使用偏向锁</p><h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><h4 id="即调用对象的hashCode"><a href="#即调用对象的hashCode" class="headerlink" title="即调用对象的hashCode"></a>即调用对象的hashCode</h4><pre><code>由于偏向锁对象的MarkWord中存储的是线程ID，调用了hashcode，会让锁标志位从101切换到001，即变为无锁状态，进而导致偏向锁被取消</code></pre><ul><li>轻量级锁会在锁记录中记录hashCode</li><li>重量级锁会在Monitor对象中记录hashCode</li></ul><h4 id="其他线程使用对象"><a href="#其他线程使用对象" class="headerlink" title="其他线程使用对象"></a>其他线程使用对象</h4><p>当其他线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><h4 id="调用wait-notify时也会撤销"><a href="#调用wait-notify时也会撤销" class="headerlink" title="调用wait/notify时也会撤销"></a>调用wait/notify时也会撤销</h4><p>因为wait/notify只有重量级锁才能使用</p><h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><pre><code>如果对象背多个线程访问，但没有竞争，这时偏向T1的对象仍有机会重新偏向T2，重偏向会重置对象的ThreadID，当撤销偏向锁阈值超过20次后，JVM会认为自己可能偏向错了，于是会在给这些对象加锁时重新偏向加锁线程。</code></pre><h3 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3><pre><code>当撤销偏量锁超过40次后，jvm会认为自己就不应该偏向，于是，整个类所有对象都变为不可偏向， 新建的对象也是不可偏向的。</code></pre><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><pre><code>涉及到jvm对没有竞态条件的代码，即在没有多线程竞争的产生竞态条件的代码块上却加了锁的情况，jvm底层会对这种情况进行优化，自动消除锁。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Synchronized关键字及进阶&quot;&gt;&lt;a href=&quot;#Synchronized关键字及进阶&quot; class=&quot;headerlink&quot; title=&quot;Synchronized关键字及进阶&quot;&gt;&lt;/a&gt;Synchronized关键字及进阶&lt;/h1&gt;&lt;p&gt;本文介绍synchronized的基本用法以及一些进阶知识&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从操作系统和JavaAPI层面解释线程的状态</title>
    <link href="https://thisiswilli.cn/2020/03/19/%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8CJavaAPI%E5%B1%82%E9%9D%A2%E8%A7%A3%E9%87%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <id>https://thisiswilli.cn/2020/03/19/%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8CJavaAPI%E5%B1%82%E9%9D%A2%E8%A7%A3%E9%87%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</id>
    <published>2020-03-19T07:57:57.000Z</published>
    <updated>2020-03-19T08:00:43.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从操作系统和JavaAPI层面解释线程的状态"><a href="#从操作系统和JavaAPI层面解释线程的状态" class="headerlink" title="从操作系统和JavaAPI层面解释线程的状态"></a>从操作系统和JavaAPI层面解释线程的状态</h1><h2 id="从操作系统层面来看"><a href="#从操作系统层面来看" class="headerlink" title="从操作系统层面来看"></a>从操作系统层面来看</h2><a id="more"></a><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E7%BA%BF%E7%A8%8B%E7%9A%845%E4%B8%AD%E7%8A%B6%E6%80%81.png" style="zoom:25%;" /><ul><li>初始状态：仅在语言层面创建了对象，还未与操作系统建立联系</li><li>可运行状态：也可以称其为就绪状态，指该线程已经被创建(与操作系统相关联)，可以由CPU调度运行</li><li>运行状态：线程已经获得了CPU时间片并在运行的状态，当cpu的时间片用完，线程会从运行状态切换到可运行状态，会导致线程的上下文切换</li><li>阻塞状态<ul><li>如果调用了阻塞的API，例如BIO读写文件，该线程不会用到CPU，会导致线程上下文切换，进入阻塞状态，调度器不会将时间片分给阻塞状态的线程</li><li>等BIO操作完成之后，由操作系统唤醒处于阻塞状态的线程，该线程状态从阻塞状态切换到可运行状态</li><li>可运行状态与阻塞状态的区别就是，阻塞状态的线程如果一直不被唤醒，那么调度器永远不会考虑它们</li></ul></li><li>终止状态：线程已经执行完毕，生命周期已经结束</li></ul><h2 id="从JavaAPI层面来理解"><a href="#从JavaAPI层面来理解" class="headerlink" title="从JavaAPI层面来理解"></a>从JavaAPI层面来理解</h2><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E4%BB%8EJavaAPI%E5%B1%82%E9%9D%A2%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81%20%281%29.png" alt=""></p><p>在JavaAPI层面，线程主要有以下几种状态</p><ul><li>NEW：线程刚刚被创建，还没有调用start()方法</li><li>RUNNABLE：当调用了start()方法之后，JavaAPI层面的RUNNABLE状态涵盖了操作系统层面的可运行状态，运行状态，阻塞状态</li><li>BLOCK：线程争夺锁失败，正在等待锁的释放，或者是线程在争夺锁的状态</li><li>WAITING：调用了join，wait方法的线程，可以被操作系统再次唤醒</li><li>TIME_WAITING：调用了sleep方法的线程</li><li>TERMINATED：当线程代码运行结束</li></ul><h3 id="NEW-–-gt-RUNNABLE"><a href="#NEW-–-gt-RUNNABLE" class="headerlink" title="NEW –&gt;  RUNNABLE"></a>NEW –&gt;  RUNNABLE</h3><ul><li>当调用<code>Thread.start()</code>方法时从NEW–&gt;RUNNABLE</li></ul><h3 id="RUNNABLE-lt-–-gt-WAITING"><a href="#RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="RUNNABLE &lt;–&gt; WAITING"></a>RUNNABLE &lt;–&gt; WAITING</h3><p>情况一：</p><ul><li><p><strong>t线程</strong>使用synchronized获取对象锁之后</p><ul><li><p>调用<code>obj.wait()</code>方法时，t线程从RUNNABLE –&gt; WAITING，并且释放了锁</p></li><li><p>调用<code>obj.notify(),obj.notifyAll(),t.interrupt()</code>时，</p><ul><li>竞争锁成功，t线程从WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t线程从WAITING–&gt;BLOCKED</li></ul></li></ul></li></ul><p>情况二：</p><ul><li><p>当前线程调用<code>t.join()</code>方法时当前线程从RUNNABLE –&gt; WAITING</p><ul><li><strong>注意是当前线程在t线程对象的Monitor上等待</strong></li></ul></li><li><p>t线程运行结束，或调用了当前线程的<code>interrupt()</code>时，当前线程从WAITING –&gt; RUNNABLE</p></li></ul><p>情况三：</p><ul><li>当前线程调用<code>LockSupport.park()</code>方法会让当前线程从RUNNABLE –&gt; WAITING</li><li>调用Lock Support.unpack(目标线程)或调用了线程的interrupt()，会让目标线程从WAITING–&gt;RUNNABLE</li></ul><h3 id="RUNNABLE-lt-–-gt-TIME-WAITING"><a href="#RUNNABLE-lt-–-gt-TIME-WAITING" class="headerlink" title="RUNNABLE &lt;–&gt; TIME_WAITING"></a>RUNNABLE &lt;–&gt; TIME_WAITING</h3><p>情况一：</p><ul><li><p><strong>t线程</strong>使用synchronized获取对象锁之后</p></li><li><p>调用<code>obj.wait(long n)</code>方法时，t线程从RUNNABLE –&gt; TIME_WAITING</p></li><li><p>t线程等待时间超过了n毫秒，或调用<code>obj.notify(),obj.notifyAll(),t.interrupt()</code>时，</p><ul><li>竞争锁成功，t线程从TIME_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t线程从TIME_WAITING–&gt;BLOCKED</li></ul></li></ul><p>情况二：</p><ul><li>当前线程调用<code>t.join(long n)</code>方法时当前线程从RUNNABLE –&gt; TIME_WAITING<ul><li>注意是当前线程在t线程对象的Monitor上等待</li></ul></li><li>当前线程等待时间超过了n毫秒，或t线程运行结束，或调用了当前线程的interrupt()时，当前线程从TIME_WAITING–&gt;RUNNABLE</li></ul><p>情况三：</p><ul><li>当前线程调用<code>t.sleep(long n)</code>，当前线程从RUNNABLE–&gt;TIME_WAITING</li><li>当前线程等待时间超过了n毫秒，当前线程从TIME_WAITING –&gt; RUNNABLE</li></ul><p>情况四：</p><ul><li>当前线程调用<code>LockSupport.parkNanos(long nanos)</code>方法或<code>LockSupport.parkUtil(long millis</code>)会让当前线程从RUNNABLE –&gt; TIME_WAITING</li><li>调用<code>LockSupport.unpack(目标线程)</code>或调用了线程的<code>interrupt()</code>，会让目标线程从TIME_WAITING–&gt;RUNNABLE</li></ul><h3 id="RUNNABLE-lt-–-gt-BLOCKED"><a href="#RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="RUNNABLE &lt;–&gt; BLOCKED"></a>RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t线程使用synchronized获取了对象锁时如果竞争失败，从RUNNABLE  –&gt; BLOCKED</li><li>持obj锁线程的同步代码块执行完毕，会唤醒该对象上所有BLOCKED的线程重新竞争，如果其中t线程竞争成功，从BLOCK–&gt;RUNNABLE，其他失败的线程仍然BLOCKED</li></ul><h3 id="RUNNABLE-lt-–-gt-TERMINATED"><a href="#RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="RUNNABLE &lt;–&gt; TERMINATED"></a>RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线程所有代码运行完毕，进入TERMINATED</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从操作系统和JavaAPI层面解释线程的状态&quot;&gt;&lt;a href=&quot;#从操作系统和JavaAPI层面解释线程的状态&quot; class=&quot;headerlink&quot; title=&quot;从操作系统和JavaAPI层面解释线程的状态&quot;&gt;&lt;/a&gt;从操作系统和JavaAPI层面解释线程的状态&lt;/h1&gt;&lt;h2 id=&quot;从操作系统层面来看&quot;&gt;&lt;a href=&quot;#从操作系统层面来看&quot; class=&quot;headerlink&quot; title=&quot;从操作系统层面来看&quot;&gt;&lt;/a&gt;从操作系统层面来看&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SparkCore源码阅读之SparkContext,SparkConf,SparkEnv</title>
    <link href="https://thisiswilli.cn/2020/03/16/SparkCore%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BSparkContext-SparkConf-SparkEnv/"/>
    <id>https://thisiswilli.cn/2020/03/16/SparkCore%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BSparkContext-SparkConf-SparkEnv/</id>
    <published>2020-03-16T14:40:57.000Z</published>
    <updated>2020-03-16T14:45:27.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SparkCore之SparkContext-SparkConf"><a href="#SparkCore之SparkContext-SparkConf" class="headerlink" title="SparkCore之SparkContext,SparkConf"></a>SparkCore之SparkContext,SparkConf</h1><h2 id="Spark程序入口"><a href="#Spark程序入口" class="headerlink" title="Spark程序入口"></a>Spark程序入口</h2><a id="more"></a><p>​        我们在编写Spark程序时，程序的入口一般都需创建SparkConf，设置SparkConf中的属性，再将SparkConf传入SparkContext中，比如一个简单的map算子程序，接下来通过SparkConf，SparkContext的源码，来解读Spark程序初始化的过程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">map</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"map"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    sc.setLogLevel(<span class="string">"Error"</span>)</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">val</span> lines = sc.textFile(<span class="string">"data/data.txt"</span>)</span><br><span class="line">    lines.map(one=&gt;&#123;</span><br><span class="line">      one + <span class="string">"#"</span></span><br><span class="line">    &#125;).foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SparkConf"><a href="#SparkConf" class="headerlink" title="SparkConf"></a>SparkConf</h2><p>SparkConf是Spark application的配置类，SparkConf主要有以下几点功能以及特点：</p><ul><li><p>在读取SparkConf参数时，SparkConf会先读取org.apache.spark下任何关于SparkConf的配置，是否读取读取默认参数可以在创建SparkConf时通过传入true或false进行设置，但是开发者通过set方法设置的SparkConf属性的优先级是高于系统设置的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">loadFromSystemProperties</span></span>(silent: <span class="type">Boolean</span>): <span class="type">SparkConf</span> = &#123;</span><br><span class="line">    <span class="comment">// Load any spark.* system properties</span></span><br><span class="line">    <span class="keyword">for</span> ((key, value) &lt;- <span class="type">Utils</span>.getSystemProperties <span class="keyword">if</span> key.startsWith(<span class="string">"spark."</span>)) &#123;</span><br><span class="line">      set(key, value, silent)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>开发者可以在SparkConf中set SparkConf中的各种参数，其中set方法都支持链式书写，如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conf.setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"map"</span>)</span><br></pre></td></tr></table></figure><p>开发者也可以通过get获取SparkConf中的参数，部分源码如下所示</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The master URL to connect to, such as "local" to run locally with one thread, "local[4]" to</span></span><br><span class="line"><span class="comment">   * run locally with 4 cores, or "spark://master:7077" to run on a Spark standalone cluster.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setMaster</span></span>(master: <span class="type">String</span>): <span class="type">SparkConf</span> = &#123;</span><br><span class="line">    set(<span class="string">"spark.master"</span>, master)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Set a name for your application. Shown in the Spark web UI. */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setAppName</span></span>(name: <span class="type">String</span>): <span class="type">SparkConf</span> = &#123;</span><br><span class="line">    set(<span class="string">"spark.app.name"</span>, name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Get a parameter; throws a NoSuchElementException if it's not set */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(key: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    getOption(key).getOrElse(<span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(key))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get a parameter, falling back to a default if not set */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(key: <span class="type">String</span>, defaultValue: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    getOption(key).getOrElse(defaultValue)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>SparkConf也定义了一个伴生对象来记录已经弃用的配置</p></li></ul><h2 id="SparkEnv"><a href="#SparkEnv" class="headerlink" title="SparkEnv"></a>SparkEnv</h2><p>SparkEnv是Spark运行程序的运行环境，SparkEnv中保留正在运行的Spark实例（主实例或工作实例）的所有运行时环境对象，SparkEnv类的构造函数如下，可见这个类中定义了Spark application运行时的环境对象</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparkEnv</span> (<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    val executorId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    private[spark] val rpcEnv: <span class="type">RpcEnv</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val serializer: <span class="type">Serializer</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val closureSerializer: <span class="type">Serializer</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val serializerManager: <span class="type">SerializerManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val mapOutputTracker: <span class="type">MapOutputTracker</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val shuffleManager: <span class="type">ShuffleManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val broadcastManager: <span class="type">BroadcastManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val blockManager: <span class="type">BlockManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val securityManager: <span class="type">SecurityManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val metricsSystem: <span class="type">MetricsSystem</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val memoryManager: <span class="type">MemoryManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val outputCommitCoordinator: <span class="type">OutputCommitCoordinator</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val conf: <span class="type">SparkConf</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">var</span> isStopped = <span class="literal">false</span></span><br><span class="line">  ....&#125;</span><br></pre></td></tr></table></figure><p>SparkContext在执行Spark application时会根据SparkConf中的设置，通过阅读SparkEnv源码中的create方法可知，SparkEnv中的运行时环境对象创建顺序如下所示，接下来我们逐个分析</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Spark/SparkEnv%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" style="zoom:25%;" /><h3 id="安全管理器SecurityManager"><a href="#安全管理器SecurityManager" class="headerlink" title="安全管理器SecurityManager"></a>安全管理器SecurityManager</h3><p>create方法中创建SecurityManager的代码如下所示，创建SecurityManager需要SparkConf中的设置以及io加密的密钥</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> securityManager = <span class="keyword">new</span> <span class="type">SecurityManager</span>(conf, ioEncryptionKey)</span><br><span class="line">    <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">      securityManager.initializeAuth()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioEncryptionKey.foreach &#123; _ =&gt;</span><br><span class="line">      <span class="keyword">if</span> (!securityManager.isEncryptionEnabled()) &#123;</span><br><span class="line">        logWarning(<span class="string">"I/O encryption enabled without RPC encryption: keys will be visible on the "</span> +<span class="string">"wire."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再看SecurityManager这个类，顾名思义，主要负责安全，主要有以下几个特点</p><ul><li><p>SecurityManager可以设置集群中的通信方式，Spark集群之间默认可以通过公钥来进行验证并通信，可以配置“ spark.authenticate”将身份验证设置为启用，进一步提高安全性</p></li><li><p>也可以通过javax servlet过滤器让对特定数据没有访问权限的用户无法访问相应的SparkUI</p></li><li><p>Spark通过个人和小组修改ACL（<code>spark.modify.acls</code>）和（<code>spark.modify.acls.groups</code>）控制哪些用户和组织有权访问修改单个Spark application</p></li><li><p>如果使用Hadoop YARN作为集群管理器，则需要使用证书生成secret key登录，最后给当前系统设置默认的口令认证实例</p></li></ul><h3 id="RPC通信环境RpcEnv"><a href="#RPC通信环境RpcEnv" class="headerlink" title="RPC通信环境RpcEnv"></a>RPC通信环境RpcEnv</h3><p>create中创建RPCEnv的代码如下所示</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rpcEnv = <span class="type">RpcEnv</span>.create(systemName, bindAddress, advertiseAddress, port.getOrElse(<span class="number">-1</span>), conf,</span><br><span class="line">      securityManager, numUsableCores, !isDriver)</span><br></pre></td></tr></table></figure><p>关于RPC的分析可以参考<a href="https://zhuanlan.zhihu.com/p/28893155" target="_blank" rel="noopener">这篇文章</a></p><h3 id="序列化管理器serializerManager"><a href="#序列化管理器serializerManager" class="headerlink" title="序列化管理器serializerManager"></a>序列化管理器serializerManager</h3><p>​        序列化管理器通过用来配置各Spark组件的序列化、压缩和加密。serializer默认实现为org.apache.spark.serializer.JavaSerializer，用户可以通过在SparkConf中自定义序列化器的类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serializer = instantiateClassFromConf[<span class="type">Serializer</span>](</span><br><span class="line">      <span class="string">"spark.serializer"</span>, <span class="string">"org.apache.spark.serializer.JavaSerializer"</span>)</span><br><span class="line">    logDebug(<span class="string">s"Using serializer: <span class="subst">$&#123;serializer.getClass&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> serializerManager = <span class="keyword">new</span> <span class="type">SerializerManager</span>(serializer, conf, ioEncryptionKey)</span><br></pre></td></tr></table></figure><h3 id="闭包序列化器closureSerializer"><a href="#闭包序列化器closureSerializer" class="headerlink" title="闭包序列化器closureSerializer"></a>闭包序列化器closureSerializer</h3><p>闭包序列化器只能为java内置序列化器，不支持用户自定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> closureSerializer = <span class="keyword">new</span> <span class="type">JavaSerializer</span>(conf)</span><br></pre></td></tr></table></figure><h3 id="广播管理器broadcastManager"><a href="#广播管理器broadcastManager" class="headerlink" title="广播管理器broadcastManager"></a>广播管理器broadcastManager</h3><p>​        create方法中创建broadcastManager代码如下所示，BroadcastManager用于将配置信息和序列化后的RDD、Job以及ShuffleDependency等信息在本地存储。如果为了容灾，也会复制到其他节点上</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> broadcastManager = <span class="keyword">new</span> <span class="type">BroadcastManager</span>(isDriver, conf, securityManager)</span><br></pre></td></tr></table></figure><p>###Map任务输出跟踪器mapOutputTracker </p><p>MapOutputTracker 用于跟踪 stage中map任务输出结果的位置</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mapOutputTracker = <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="type">MapOutputTrackerMaster</span>(conf, broadcastManager, isLocal)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="type">MapOutputTrackerWorker</span>(conf)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>MapOutputTrackerMaster属于Driver，负责追踪当前Spark application上所有Shuffle的Map输出元数据信息</li><li>MapOutputTrackerWorker是运行在Executor中的，负责拉取MapOutputTrackerMaster端的map输出数据，进行reduce任务</li></ul><h3 id="ShuffleManager"><a href="#ShuffleManager" class="headerlink" title="ShuffleManager"></a>ShuffleManager</h3><p>​        Spark的stage与stage之间的过程就是 shuffle 阶段，在 Spark 中，负责 shuffle 过程的执行、计算和处理的组件主要就是 <strong>ShuffleManager</strong> 。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> shuffleManager = instantiateClass[<span class="type">ShuffleManager</span>](shuffleMgrClass)</span><br></pre></td></tr></table></figure><h3 id="MemoryManager"><a href="#MemoryManager" class="headerlink" title="MemoryManager"></a>MemoryManager</h3><p>​        一种抽象内存管理器，用于强制执行和存储之间共享内存的方式。在这个上下文下，执行内存是指用于在shuffle，join，sort和aggregation中进行计算的内存，而存储内存是指用于在群集中缓存和传播内部数据的内存。 每个JVM都有一个MemoryManager。</p><p>​        UnifiedMemoryManager和StaticMemoryManager继承了MemoryManager这个抽象类，spark1.6+默认使用UnifiedMemoryManager</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> useLegacyMemoryManager = conf.getBoolean(<span class="string">"spark.memory.useLegacyMode"</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> memoryManager: <span class="type">MemoryManager</span> =</span><br><span class="line">      <span class="keyword">if</span> (useLegacyMemoryManager) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">StaticMemoryManager</span>(conf, numUsableCores)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">UnifiedMemoryManager</span>(conf, numUsableCores)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="blockManager"><a href="#blockManager" class="headerlink" title="blockManager"></a>blockManager</h3><p>blockManager运行在每个节点上，包括driver和Executor，提供对本地或远端节点上的内存、磁盘及堆外内存中Block的管理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NB: blockManager is not valid until initialize() is called later.</span></span><br><span class="line"><span class="keyword">val</span> blockManager = <span class="keyword">new</span> <span class="type">BlockManager</span>(executorId, rpcEnv, blockManagerMaster,</span><br><span class="line">      serializerManager, conf, memoryManager, mapOutputTracker, shuffleManager,</span><br><span class="line">      blockTransferService, securityManager, numUsableCores)</span><br></pre></td></tr></table></figure><h3 id="metricsSystem"><a href="#metricsSystem" class="headerlink" title="metricsSystem"></a>metricsSystem</h3><p>Spark中的master, worker, executor, client driver都可以创建metricsSystem，metricsSytem用来监控Spark组件中的各种指标信息，例如MasterSource, WorkerSource或JvmSource，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> metricsSystem = <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">      <span class="comment">// Don't start metrics system right now for Driver.</span></span><br><span class="line">      <span class="comment">// We need to wait for the task scheduler to give us an app ID.</span></span><br><span class="line">      <span class="comment">// Then we can start the metrics system.</span></span><br><span class="line">      <span class="type">MetricsSystem</span>.createMetricsSystem(<span class="string">"driver"</span>, conf, securityManager)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We need to set the executor ID before the MetricsSystem is created because sources and</span></span><br><span class="line">      <span class="comment">// sinks specified in the metrics configuration file will want to incorporate this executor's</span></span><br><span class="line">      <span class="comment">// ID into the metrics they report.</span></span><br><span class="line">      conf.set(<span class="string">"spark.executor.id"</span>, executorId)</span><br><span class="line">      <span class="keyword">val</span> ms = <span class="type">MetricsSystem</span>.createMetricsSystem(<span class="string">"executor"</span>, conf, securityManager)</span><br><span class="line">      ms.start()</span><br><span class="line">      ms</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="outputCommitCoordinator"><a href="#outputCommitCoordinator" class="headerlink" title="outputCommitCoordinator"></a>outputCommitCoordinator</h3><p>决定任务是否可以将输出数据提交到HDFS</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> outputCommitCoordinator = mockOutputCommitCoordinator.getOrElse &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">OutputCommitCoordinator</span>(conf, isDriver)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="SparkContext"><a href="#SparkContext" class="headerlink" title="SparkContext"></a>SparkContext</h2><p>​        SparkContext是Spark application的主要入口，SparkContext代表着应用程序与Spark集群的连接，开发者可以使用SparkContext在集群中创建RDD，累加器，或者广播变量。需要注意的是，在每个JVM中只能有一个正在运行的SparkContext，如果要让新的SparkContext在JVM中运行，必须先停止正在运行的SparkContext。</p><p>创建的大致流程图如下</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/SparkContext%E6%B5%81%E7%A8%8B.001.png" style="zoom:70%;" /><ul><li><p>SparkContext在创建之前，会确认是否允许多个SparkContext同时在JVM中运行，如果Spark允许，那么只生成警告，若不允许则抛出异常</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If true, log warnings instead of throwing exceptions when multiple SparkContexts are active</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> allowMultipleContexts: <span class="type">Boolean</span> =</span><br><span class="line">    config.getBoolean(<span class="string">"spark.driver.allowMultipleContexts"</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In order to prevent multiple SparkContexts from being active at the same time, mark this</span></span><br><span class="line">  <span class="comment">// context as having started construction.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> this must be placed at the beginning of the SparkContext constructor.</span></span><br><span class="line">  <span class="type">SparkContext</span>.markPartiallyConstructed(<span class="keyword">this</span>, allowMultipleContexts)</span><br></pre></td></tr></table></figure></li><li><p>接下来SparkContext中定义了以下这些私有变量，这其中有很多Spark application创建过程中的重要组件，这些变量是只能通过SparkContext中定义的一系列类似java类中的get方法来访问的，但是在运行过程中是不能够改变的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _conf: <span class="type">SparkConf</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _eventLogDir: <span class="type">Option</span>[<span class="type">URI</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _eventLogCodec: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _listenerBus: <span class="type">LiveListenerBus</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _env: <span class="type">SparkEnv</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _statusTracker: <span class="type">SparkStatusTracker</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _progressBar: <span class="type">Option</span>[<span class="type">ConsoleProgressBar</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _ui: <span class="type">Option</span>[<span class="type">SparkUI</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _hadoopConfiguration: <span class="type">Configuration</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _executorMemory: <span class="type">Int</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _schedulerBackend: <span class="type">SchedulerBackend</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _taskScheduler: <span class="type">TaskScheduler</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _heartbeatReceiver: <span class="type">RpcEndpointRef</span> = _</span><br><span class="line"> <span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _dagScheduler: <span class="type">DAGScheduler</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _applicationId: <span class="type">String</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _applicationAttemptId: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _eventLogger: <span class="type">Option</span>[<span class="type">EventLoggingListener</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _executorAllocationManager: <span class="type">Option</span>[<span class="type">ExecutorAllocationManager</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _cleaner: <span class="type">Option</span>[<span class="type">ContextCleaner</span>] = <span class="type">None</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _listenerBusStarted: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _jars: <span class="type">Seq</span>[<span class="type">String</span>] = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _files: <span class="type">Seq</span>[<span class="type">String</span>] = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _shutdownHookRef: <span class="type">AnyRef</span> = _</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> _statusStore: <span class="type">AppStatusStore</span> = _</span><br></pre></td></tr></table></figure></li><li><p>在创建SparkContext的过程中，会检查SparkConf中的配置是否完整，如果缺少某些关键配置，则会抛出异常，并判断是以什么形式提交Spark任务</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_conf.contains(<span class="string">"spark.master"</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"A master URL must be set in your configuration"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_conf.contains(<span class="string">"spark.app.name"</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"An application name must be set in your configuration"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log out spark.app.name in the Spark driver logs</span></span><br><span class="line">    logInfo(<span class="string">s"Submitted application: <span class="subst">$appName</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// System property spark.yarn.app.id must be set if user code ran by AM on a YARN cluster</span></span><br><span class="line">    <span class="keyword">if</span> (master == <span class="string">"yarn"</span> &amp;&amp; deployMode == <span class="string">"cluster"</span> &amp;&amp; !_conf.contains(<span class="string">"spark.yarn.app.id"</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"Detected yarn cluster mode, but isn't running on a cluster. "</span> +</span><br><span class="line">        <span class="string">"Deployment to YARN is not supported directly by SparkContext. Please use spark-submit."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_conf.getBoolean(<span class="string">"spark.logConf"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      logInfo(<span class="string">"Spark configuration:\n"</span> + _conf.toDebugString)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来SparkContext会对Driver进行一系列配置，部分代码如下所示</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set Spark driver host and port system properties. This explicitly sets the configuration</span></span><br><span class="line">   <span class="comment">// instead of relying on the default value of the config constant.</span></span><br><span class="line">   _conf.set(<span class="type">DRIVER_HOST_ADDRESS</span>, _conf.get(<span class="type">DRIVER_HOST_ADDRESS</span>))</span><br><span class="line">   _conf.setIfMissing(<span class="string">"spark.driver.port"</span>, <span class="string">"0"</span>)</span><br><span class="line">  </span><br><span class="line">   _conf.set(<span class="string">"spark.executor.id"</span>, <span class="type">SparkContext</span>.<span class="type">DRIVER_IDENTIFIER</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Create the Spark execution environment (cache, map output tracker, etc)</span></span><br><span class="line">   _env = createSparkEnv(_conf, isLocal, listenerBus)</span><br><span class="line">   <span class="type">SparkEnv</span>.set(_env)</span><br></pre></td></tr></table></figure></li><li><p>在创建TaskScheduler之前创建Sparkui，这样能让Sparkui更好监听Spark任务中的各项指标</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ui =</span><br><span class="line">      <span class="keyword">if</span> (conf.getBoolean(<span class="string">"spark.ui.enabled"</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="type">Some</span>(<span class="type">SparkUI</span>.create(<span class="type">Some</span>(<span class="keyword">this</span>), _statusStore, _conf, _env.securityManager, appName, <span class="string">""</span>,</span><br><span class="line">          startTime))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For tests, do not enable the UI</span></span><br><span class="line">        <span class="type">None</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// Bind the UI before starting the task scheduler to communicate</span></span><br><span class="line">    <span class="comment">// the bound port to the cluster manager properly</span></span><br><span class="line">    _ui.foreach(_.bind())</span><br></pre></td></tr></table></figure></li><li><p>接下来对Executor的内存大小进行配置，并根据配置创建ExecutorEnv</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_executorMemory = _conf.getOption(<span class="string">"spark.executor.memory"</span>)</span><br><span class="line">      .orElse(<span class="type">Option</span>(<span class="type">System</span>.getenv(<span class="string">"SPARK_EXECUTOR_MEMORY"</span>)))</span><br><span class="line">      .orElse(<span class="type">Option</span>(<span class="type">System</span>.getenv(<span class="string">"SPARK_MEM"</span>))</span><br><span class="line">      .map(warnSparkMem))</span><br><span class="line">      .map(<span class="type">Utils</span>.memoryStringToMb)</span><br><span class="line">      .getOrElse(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert java options to env vars as a work around</span></span><br><span class="line">    <span class="comment">// since we can't set env vars directly in sbt.</span></span><br><span class="line">    <span class="keyword">for</span> &#123; (envKey, propKey) &lt;- <span class="type">Seq</span>((<span class="string">"SPARK_TESTING"</span>, <span class="string">"spark.testing"</span>))</span><br><span class="line">      value &lt;- <span class="type">Option</span>(<span class="type">System</span>.getenv(envKey)).orElse(<span class="type">Option</span>(<span class="type">System</span>.getProperty(propKey)))&#125; &#123;</span><br><span class="line">      executorEnvs(envKey) = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Option</span>(<span class="type">System</span>.getenv(<span class="string">"SPARK_PREPEND_CLASSES"</span>)).foreach &#123; v =&gt;</span><br><span class="line">      executorEnvs(<span class="string">"SPARK_PREPEND_CLASSES"</span>) = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The Mesos scheduler backend relies on this environment variable to set executor memory.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Set this only in the Mesos scheduler.</span></span><br><span class="line">    executorEnvs(<span class="string">"SPARK_EXECUTOR_MEMORY"</span>) = executorMemory + <span class="string">"m"</span></span><br><span class="line">    executorEnvs ++= _conf.getExecutorEnv</span><br><span class="line">    executorEnvs(<span class="string">"SPARK_USER"</span>) = sparkUser</span><br></pre></td></tr></table></figure></li><li><p>创建心跳检测器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need to register "HeartbeatReceiver" before "createTaskScheduler" because Executor will</span></span><br><span class="line">    <span class="comment">// retrieve "HeartbeatReceiver" in the constructor. (SPARK-6640)</span></span><br><span class="line">    _heartbeatReceiver = env.rpcEnv.setupEndpoint(</span><br><span class="line">      <span class="type">HeartbeatReceiver</span>.<span class="type">ENDPOINT_NAME</span>, <span class="keyword">new</span> <span class="type">HeartbeatReceiver</span>(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure></li><li><p>创建DAGScheduler和TaskScheduler</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and start the scheduler</span></span><br><span class="line">    <span class="keyword">val</span> (sched, ts) = <span class="type">SparkContext</span>.createTaskScheduler(<span class="keyword">this</span>, master, deployMode)</span><br><span class="line">    _schedulerBackend = sched</span><br><span class="line">    _taskScheduler = ts</span><br><span class="line">    _dagScheduler = <span class="keyword">new</span> <span class="type">DAGScheduler</span>(<span class="keyword">this</span>)</span><br><span class="line">    _heartbeatReceiver.ask[<span class="type">Boolean</span>](<span class="type">TaskSchedulerIsSet</span>)</span><br></pre></td></tr></table></figure></li><li><p>启动TaskScheduler</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start TaskScheduler after taskScheduler sets DAGScheduler reference in DAGScheduler's</span></span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    _taskScheduler.start()</span><br></pre></td></tr></table></figure></li><li><p>启动metricSystem给Spark Application id 赋值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The metrics system for Driver need to be set spark.app.id to app ID.</span></span><br><span class="line">    <span class="comment">// So it should start after we get app ID from the task scheduler and set spark.app.id.</span></span><br><span class="line">    _env.metricsSystem.start()</span><br><span class="line">    <span class="comment">// Attach the driver metrics servlet handler to the web ui after the metrics system is started.</span></span><br><span class="line">    _env.metricsSystem.getServletHandlers.foreach(handler =&gt; ui.foreach(_.attachHandler(handler)))</span><br></pre></td></tr></table></figure></li><li><p>调用一下三个方法，创建SparkContext</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setupAndStartListenerBus()</span><br><span class="line">  postEnvironmentUpdate()</span><br><span class="line">  postApplicationStart()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SparkCore之SparkContext-SparkConf&quot;&gt;&lt;a href=&quot;#SparkCore之SparkContext-SparkConf&quot; class=&quot;headerlink&quot; title=&quot;SparkCore之SparkContext,SparkConf&quot;&gt;&lt;/a&gt;SparkCore之SparkContext,SparkConf&lt;/h1&gt;&lt;h2 id=&quot;Spark程序入口&quot;&gt;&lt;a href=&quot;#Spark程序入口&quot; class=&quot;headerlink&quot; title=&quot;Spark程序入口&quot;&gt;&lt;/a&gt;Spark程序入口&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Spark" scheme="https://thisiswilli.cn/categories/Spark/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中变量的线程安全分析</title>
    <link href="https://thisiswilli.cn/2020/03/14/Java%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/"/>
    <id>https://thisiswilli.cn/2020/03/14/Java%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</id>
    <published>2020-03-14T13:39:32.000Z</published>
    <updated>2020-03-14T13:41:01.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h1><p>本文分析对Java程序中的变量是否安全进行分析</p><a id="more"></a><h2 id="成员变量和静态变量是否线程安全"><a href="#成员变量和静态变量是否线程安全" class="headerlink" title="成员变量和静态变量是否线程安全"></a>成员变量和静态变量是否线程安全</h2><ul><li>如果它们没有共享，则是线程安全的</li><li>若它们被共享了，根据它们的状态是否能够改变，分成两种情况<ul><li>若只是读操作，则线程安全</li><li>若是读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h2 id="局部变量是否线程安全"><a href="#局部变量是否线程安全" class="headerlink" title="局部变量是否线程安全"></a>局部变量是否线程安全</h2><ul><li>局部变量是线程安全的</li><li>但是有一种情况需要注意，当局部变量引用是对象时<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该该对象逃离了方法的作用范围，则需要考虑线程安全</li></ul></li></ul><h2 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h2><h3 id="局部变量是基本类型或者包装类型"><a href="#局部变量是基本类型或者包装类型" class="headerlink" title="局部变量是基本类型或者包装类型"></a>局部变量是基本类型或者包装类型</h3><p>如果局部变量是基本类型或者包装类型，那么局部变量是线程安全的，如下代码所示，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariableTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test1();</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            test1();</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程在执行test1方法是，都会在自己的栈帧中创建一份局部变量i的副本，两个线程的i互不影响，所以是线程安全的</p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%88%86%E5%88%AB%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E6%A0%88%E5%B8%A7.png" style="zoom:50%;" /><h3 id="局部变量引用的是一个对象，但是没有暴露给外部"><a href="#局部变量引用的是一个对象，但是没有暴露给外部" class="headerlink" title="局部变量引用的是一个对象，但是没有暴露给外部"></a>局部变量引用的是一个对象，但是没有暴露给外部</h3><p>​        如果局部变量引用的是一个对象，但是这个对象没有暴露给外部，那么还是线程安全的，如下代码所示，两个线程分别调用method1方法，但是每个线程维护着自己的栈，会在自己的栈中创建一个ArrayList，两个线程互不影响，不会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariableTest3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOP_NUM = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSafe test = <span class="keyword">new</span> ThreadSafe();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                test.method1(LOOP_NUM);</span><br><span class="line">            &#125;, <span class="string">"Thread"</span> + i + <span class="number">1</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++)&#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量引用的是一个对象，但是这个对象暴露给了外部线程"><a href="#局部变量引用的是一个对象，但是这个对象暴露给了外部线程" class="headerlink" title="局部变量引用的是一个对象，但是这个对象暴露给了外部线程"></a>局部变量引用的是一个对象，但是这个对象暴露给了外部线程</h3><p>​        当局部变量引用的是一个对象，当一个线程在自己的栈中创建了这个对象的副本后，如果一直是这个线程对这个对象进行操作，不会发生，但是，当把这个对象暴露给外部，让别的线程也能来操作它，那么就会出现问题，</p><p>​        如下代码所示，如果用一个子类继承ThreadSafe并重写了移除元素的方法，重新创建一个线程来移除list中的元素，那么，原来是t1,t2分别执行method1方法，两个线程在自己维护的栈中分别创建了一个list，但是执行method3时，新创建出来的线程会对两个线程中的list进行操作，<strong>相当于两个线程同时对一个list进行操作，就产生了竟态条件</strong>，如果不加锁，就会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariableTest3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOP_NUM = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ThreadSafe test = new ThreadSafe();</span></span><br><span class="line">        ThreadSafeSubClass test = <span class="keyword">new</span> ThreadSafeSubClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                test.method1(LOOP_NUM);</span><br><span class="line">            &#125;, <span class="string">"Thread"</span> + i + <span class="number">1</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++)&#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码，会报如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-399&quot; java.lang.IndexOutOfBoundsException: Index: 0, Size: 0</span><br><span class="line">at java.util.ArrayList.rangeCheck(ArrayList.java:657)</span><br><span class="line">at java.util.ArrayList.remove(ArrayList.java:496)</span><br><span class="line">at com.concurrency.synchronizedstudy.ThreadSafeSubClass.lambda$method3$0(LocalVariableTest3.java:49)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;变量的线程安全分析&quot;&gt;&lt;a href=&quot;#变量的线程安全分析&quot; class=&quot;headerlink&quot; title=&quot;变量的线程安全分析&quot;&gt;&lt;/a&gt;变量的线程安全分析&lt;/h1&gt;&lt;p&gt;本文分析对Java程序中的变量是否安全进行分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Thread对象中的方法和属性</title>
    <link href="https://thisiswilli.cn/2020/03/13/Thread%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>https://thisiswilli.cn/2020/03/13/Thread%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</id>
    <published>2020-03-13T08:55:37.000Z</published>
    <updated>2020-03-13T09:00:25.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread对象中的方法和属性"><a href="#Thread对象中的方法和属性" class="headerlink" title="Thread对象中的方法和属性"></a>Thread对象中的方法和属性</h1><p>本文对java.lang包中的Thread类中的部分方法及属性进行介绍</p><a id="more"></a><h2 id="start和run方法"><a href="#start和run方法" class="headerlink" title="start和run方法"></a>start和run方法</h2><ul><li>start，是让线程启动的方法，start方法是不能重复多次调用的，多次调用会报错</li><li>run，是线程启动之后执行的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAndRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is running.."</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        上面的代码，如果调用的run()那么打印输出的会是主线程，如果调用的是start()方法，那么打印输出的会是新创建的Thread线程。</p><h2 id="sleep和yield方法"><a href="#sleep和yield方法" class="headerlink" title="sleep和yield方法"></a>sleep和yield方法</h2><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><ul><li>会让当前线程从running状态切换到time waiting状态</li><li>其他线程可以使用interrupt方法打断正在睡眠的线程，此时睡眠线程会抛出异常</li><li>睡眠结束后的线程未必立即执行，因为有可能cpu还在执行别的线程，没有时间片分给它</li><li>建议使用TimeUnit的sleep</li><li>sleep不会释放锁</li></ul><p>执行一下代码，线程t1被主线程打断之后，会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"is sleeping"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"is interrupted"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1is sleeping</span><br><span class="line">t1is interrupted</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">at com.concurrency.threadstructure.ThreadSleep.lambda$main$0(ThreadSleep.java:17)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>会让当前线程从running切换到runnable就绪状态，也就是先将时间片让给别的线程，然后调用其他同优先级的线程，如果这时没有同优先级的线程，那么不能保证让当前线程暂停的效果</li><li>具体实现依赖操作系统的线程调度器，会出现想让没有让出去的现象，也就是时间片资源较为丰富，该线程即使一直执行yield方法让出时间片，但是调度器还是会分配空闲的时间片让它执行</li></ul><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ul><li><strong>调用了yield的线程还有可能继续运行</strong>，但是调用了sleep方法的线程不可能继续运行，因为cpu不会分配时间片给time waiting状态的线程</li><li>sleep可以指定时间，yield只是存粹调用</li></ul><h2 id="线程优先级-setPriority"><a href="#线程优先级-setPriority" class="headerlink" title="线程优先级-setPriority()"></a>线程优先级-setPriority()</h2><ul><li><p>线程优先级会提示系统线程调度器优先调度该线程，但是它仅仅是一个提示，线程调度器可以忽视它</p></li><li><p>如果cpu较忙，优先级较高的线程会获得较多的时间片，cpu不忙时，线程优先级几乎没有作用</p><p>​    下列代码可显著看出在t2线程一直调用yield方法时，t1线程打印的次数会明显增多，调整每个线程的优先级也会影响打印次数。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                System.out.println(<span class="string">"----&gt;1"</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                System.out.println(<span class="string">"      ----&gt;2"</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>​        如果一个线程中对另一个Thread对象调用了join方法，那么这个线程必须要等那个Thread对象执行完毕之后，才能继续执行。</p><h2 id="线程的同步和异步"><a href="#线程的同步和异步" class="headerlink" title="线程的同步和异步"></a>线程的同步和异步</h2><p>以调用方法的角度来理解：</p><ul><li>两个线程在运行时，如果一个线程需要等待另一个线程完成之后才能继续运行，那么这种情况叫做同步。</li><li>两个线程在运行时，一个线程不需要关系另一个线程的运行状态，那么这种情况叫做异步。</li></ul><h2 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h2><ul><li><p>用interrupt方法来打断阻塞状态的线程，一般指调用了sleep， wait， join等方法的线程，</p><p>​        如果正在执行这些方法的线程被打断，那么其isInterrupted()这个线程会抛出异常，但是它会将isInterrupted()这个方法的执行结果置为false，这很奇怪，如果我们获取这个线程是否被打断的结果，我们会得到false，这会影响到我们后续判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterrupt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">      <span class="comment">// 主线程先睡500ms</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">      <span class="comment">// 主线程打断t1线程</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">at com.concurrency.threadstructure.ThreadInterrupt.lambda$main$0(ThreadInterrupt.java:16)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></li><li><p>如果我们用interrupt方法打断的是正在运行的线程，</p><p>​        如下所示，主线程调用了interrupt之后，t1不会被立刻打断，<strong>相当于t1只是被告知主线程想要打断你</strong>，t1需要自行判断是否被打断，若打断，可以执行一些措施之后，比如释放锁，在让线程终止，这样更加安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterrupt2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"被打断了"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1被打断了</span><br></pre></td></tr></table></figure><h2 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h2><p>都可能造成锁资源无法释放，不推荐使用</p><ul><li>stop()</li><li>suspend()</li><li>resume()</li></ul><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>​        默认情况下，Java进程需要等待所有线程都运行结束，才会结束，有一种特殊的线程叫做守护线程，<strong>只要其他非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束</strong>。</p><p>​        如下代码所示，执行如下代码，主线程在执行完之后，daemon线程依然会继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread daemon = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"daemon"</span>);</span><br><span class="line">        daemon.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若将daemon线程设置为守护线程，当主线程结束后，java程序停止运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread daemon = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"daemon"</span>);</span><br><span class="line">        daemon.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        daemon.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>守护线程的应用场景</p><ul><li>垃圾回收线程就是一种守护线程</li><li>Tomcat中的Acceptor和Poller线程也是守护线程</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Thread对象中的方法和属性&quot;&gt;&lt;a href=&quot;#Thread对象中的方法和属性&quot; class=&quot;headerlink&quot; title=&quot;Thread对象中的方法和属性&quot;&gt;&lt;/a&gt;Thread对象中的方法和属性&lt;/h1&gt;&lt;p&gt;本文对java.lang包中的Thread类中的部分方法及属性进行介绍&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://thisiswilli.cn/2020/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://thisiswilli.cn/2020/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-10T11:18:28.000Z</published>
    <updated>2020-03-10T11:28:34.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>​        在单例模式使得一个类的对象成为该类所在系统的唯一实例，单例模式适合用于需要重复创建的类，比如配置文件类。单例模式能够减少系统内存开销，降低GC压力。</p><a id="more"></a><h3 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式有以下几点特点</p><ul><li>在类加载时就创建对象，即在类中将对象定义成static类型的类变量，跟随类一起加载，这种方式类似于<strong>空间换时间</strong></li><li>将构造器私有，让别的类不能创建对象</li><li>提供一个全局访问点，即提供一个public的以类自身为返回值的方法</li><li><strong>懒汉式是线程安全的</strong></li></ul><p>代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungryMode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在类加载时直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungryMode hungryMode = <span class="keyword">new</span> HungryMode();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungryMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungryMode <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungryMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hungry mode"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HungryMode.getInstance().say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>懒汉式具有以下几个特点</p><ul><li>懒汉式在第一次使用时才进行加载，这样在起初能够减少内存的占用，但是会导致第一次使用类时加载速度较慢</li><li>懒汉模式是以时间换空间</li><li>懒汉模式存在线程不安全的风险</li></ul><p>代码实现</p><h5 id="不考虑线程安全的简单实现"><a href="#不考虑线程安全的简单实现" class="headerlink" title="不考虑线程安全的简单实现"></a>不考虑线程安全的简单实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMode lazyMode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMode</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyMode <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazyMode = <span class="keyword">new</span> LazyMode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加一把锁"><a href="#加一把锁" class="headerlink" title="加一把锁"></a>加一把锁</h5><p>​        上面这种情况，如果多线程访问，可能会导致重复创建对象的情况出现，针对这种情况，可以在getInstance方法上加一把锁，这种方式实现很简单，但是每次调用getIntance方法拿到实例对象时，都需要拿到锁，可能会造成线程阻塞的情况出现，效率不高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModeSingleLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyModeSingleLock lazyModeSingleLock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyModeSingleLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  LazyModeSingleLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyModeSingleLock == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazyModeSingleLock = <span class="keyword">new</span> LazyModeSingleLock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyModeSingleLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加两把锁"><a href="#加两把锁" class="headerlink" title="加两把锁"></a>加两把锁</h5><p>解释一下为什么需要使用volatile修饰LazyModeDCL实例</p><ul><li><p>防止指令重排序</p><p>创建一个对象是一个非原子操作，创建一个对象分为一下几个步骤</p><ul><li>开辟内存空间–a</li><li>调用构造器创建对象–b</li><li>返回地址给对象引用–c</li></ul><p>指令重排序之后可能会出现a-&gt;c-&gt;b的执行顺序，线程一执行了重排序之后的代码返回了，对象地址的引用到主内存中，线程一释放了锁，但是线程二拿到锁之后，直接判定lazyModeDCL对象不为空，那么线程二拿到的很可能是还在初始化的一个对象。</p><p>Ps：但是有一种说法是，执行synchronized代码块中代码会等对象创建完之后再释放锁，所以上面的说法有不成立了。。。先留一个坑，等研究透synchronized再来填坑！</p><p><img src="https://pic1.zhimg.com/50/v2-99efda8df0ea883f1be403311eb4d824_hd.jpg" alt=""></p></li><li><p>保证可见性</p><p>如果线程一在自己的工作内存中创建了LazyModeDCL实例，释放了锁，但是还没有将结果同步到主内存中，这样会导致线程二在拿到了锁之后又创建了一个对象，如果使用volatile，就能让线程二中LazyModeDCL的缓存行失效，重新去主存中读取数据</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModeDCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyModeDCL lazyModeDCL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyModeDCL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyModeDCL <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyModeDCL == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyModeDCL<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyModeDCL == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyModeDCL = <span class="keyword">new</span> LazyModeDCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyModeDCL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用静态内部类"><a href="#使用静态内部类" class="headerlink" title="使用静态内部类"></a>使用静态内部类</h5><p>静态内部类的加载机制属于被动引用的行列，即在外部类初始化时，静态内部类如果没有被使用，就不会主动加载，静态内部类的方式类似于饿汉模式，也是线程安全的，但是使用这种方式将无法传参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModeStaticClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyModeStaticClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">setInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> LazyModeStaticClass INSTANCE = <span class="keyword">new</span> LazyModeStaticClass();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyModeStaticClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> setInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingle &#123;</span><br><span class="line">    <span class="comment">// INSTANCE;</span></span><br><span class="line">  EnumSingle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(EnumSingle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;p&gt;​        在单例模式使得一个类的对象成为该类所在系统的唯一实例，单例模式适合用于需要重复创建的类，比如配置文件类。单例模式能够减少系统内存开销，降低GC压力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://thisiswilli.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://thisiswilli.cn/tags/Java/"/>
    
      <category term="设计模式" scheme="https://thisiswilli.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式和抽象工厂模式</title>
    <link href="https://thisiswilli.cn/2020/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://thisiswilli.cn/2020/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-09T14:32:44.000Z</published>
    <updated>2020-03-10T11:28:41.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>​        工厂模式在设计模式中属于创建者模式，工厂模式的目的是不让创建对象时不把创建逻辑暴露给客户端，并且通过一个统一接口来指向创建对象</p><a id="more"></a><h3 id="核心本质"><a href="#核心本质" class="headerlink" title="核心本质"></a>核心本质</h3><ul><li><strong>实例化对象不是用new而使用工厂方法代替</strong></li><li>将选择实现类，创建对象统一管理和控制，从而将调用者与使用者解耦</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>​        简单工厂模式又称静态工厂模式，简单工厂创建一个工厂类，根据客户端传入的不同参数，来创建不同的产品(类)。而这些被创建的类都实现同一个接口。简单工厂模式适合在产品类较少的环境下使用，因为这样能够避免工厂类中的代码逻辑过于复杂。</p><h4 id="简单工厂所包含的角色"><a href="#简单工厂所包含的角色" class="headerlink" title="简单工厂所包含的角色"></a>简单工厂所包含的角色</h4><ul><li>产品接口：担任简单工厂所创建产品的父类，用interface实现</li><li>产品类：简单工厂所创建的产品实例，都实现了产品接口</li><li>工厂类：核心类，包含着产品类的创建逻辑，客户端直接与工厂类交互来获得新产品</li></ul><h4 id="简单工厂的优缺点"><a href="#简单工厂的优缺点" class="headerlink" title="简单工厂的优缺点"></a>简单工厂的优缺点</h4><p>优点：</p><ul><li>工厂类能够使产品的创建与产品的消费实现解耦，让客户端不需要了解产品是怎么创建的，只需负责消费即可，如果没有工厂类，那么客户端在获取一个产品类的时候就要先去创建产品，客户端同时负责创建和消费产品，这样代码之间过于耦合。</li><li>客户端不用掌握产品类的具体信息，只要根据一些必要参数，就能让工厂类完成所需类的创建</li><li>在工厂模式下，产品的添加与删除都不用修改客户端的代码，提高了系统的灵活性</li></ul><p>缺点：</p><ul><li>系统扩展较为复杂，如果需要添加一个新的产品，就需新创建一个产品类，并需要更改工厂类中的代码，如果产品很多，会使得工厂类中的代码逻辑较为复杂，难以维护</li></ul><h4 id="简单工厂的实现"><a href="#简单工厂的实现" class="headerlink" title="简单工厂的实现"></a>简单工厂的实现</h4><p>uml图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%9B%BE.png" alt=""></p><ul><li><p>首先创建一个车的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建两个产品类，并实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"特斯拉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLing</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"五菱宏光"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建工厂类，并用静态方法完成对产品类的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Car <span class="title">buyCar</span><span class="params">(String car)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (car.equals(<span class="string">"WuLing"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WuLing();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (car.equals(<span class="string">"Tesla"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消费者，如下代码所示，消费者如果要购买Tesla，他不需要了解Tesla的具体信息，只需要创建一个工厂，并告诉工厂，他需要购买一辆特斯拉，也就是传入Tesla字符串，就能得到一个Tesla实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car tesla = <span class="keyword">new</span> CarFactory().buyCar(<span class="string">"Tesla"</span>);</span><br><span class="line">        tesla.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>​        在工厂模式下，每一样产品都有自己对应的生产工厂，客户端只需要知道所需产品的工厂名称，即可通过创建工厂来获得产品</p><h4 id="工厂模式的角色"><a href="#工厂模式的角色" class="headerlink" title="工厂模式的角色"></a>工厂模式的角色</h4><ul><li>工厂接口：每个产品工厂的父类，定义每个产品工厂的功能</li><li>子类工厂：每个产品所对应的工厂，负责生产对应的产品</li><li>产品类</li></ul><h4 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h4><p>优点：</p><ul><li>客户端不需要知道类的具体信息，只需要知道类对应的工厂，然后创建该工厂，就能获得产品</li><li>扩展性好，新添加一样产品，只需新创建一个该产品的工厂类即可。</li><li>屏蔽产品的具体实现，客户端只关心产品的接口。</li></ul><p>缺点</p><ul><li>如果添加的产品过多，可能会使类的个数成倍增长，增加了系统的复杂度</li></ul><h4 id="工厂模式的实现"><a href="#工厂模式的实现" class="headerlink" title="工厂模式的实现"></a>工厂模式的实现</h4><p>uml图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8Fuml%E5%9B%BE.png" alt=""></p><ul><li><p>创建实体类的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"特斯拉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLing</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"五菱宏光"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建工厂类的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建每个床品对应的工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeslaCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLingFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WuLing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消费者来消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car wuling = <span class="keyword">new</span> WuLingFactory().getCar();</span><br><span class="line">        Car tesla = <span class="keyword">new</span> TeslaCarFactory().getCar();</span><br><span class="line">        wuling.name();</span><br><span class="line">        tesla.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="抽像工厂模式"><a href="#抽像工厂模式" class="headerlink" title="抽像工厂模式"></a>抽像工厂模式</h3><p>​        在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h4 id="抽象工厂的角色"><a href="#抽象工厂的角色" class="headerlink" title="抽象工厂的角色"></a>抽象工厂的角色</h4><ul><li>超级工厂：所有工厂的抽象化实现，超级工厂生产抽象的产品，具体产品的生产交给子类去做</li><li>产品的抽象类</li><li>工厂类</li><li>产品类</li></ul><h4 id="抽象工厂的优缺点"><a href="#抽象工厂的优缺点" class="headerlink" title="抽象工厂的优缺点"></a>抽象工厂的优缺点</h4><p>优点：</p><ul><li>客户端不需要知道什么被生产了，只需接受生产类给他生产的产品</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的工厂和产品族很方便，无需修改已有系统，符合开闭原则，比如下面实现的例子，如果我要加一个苹果工厂的实例，只需要增加一个苹果工厂并实现超级工厂这个接口即可</li></ul><p>缺点：</p><ul><li>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，比如下面如果需要增加一个手表类，那么原来的代码很多地方都要修改。</li></ul><h4 id="抽象工厂的实现"><a href="#抽象工厂的实现" class="headerlink" title="抽象工厂的实现"></a>抽象工厂的实现</h4><p>uml图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82uml.png" alt=""></p><ul><li><p>首相创建两个抽象的产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RouteProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建两个抽象产品相应的产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title">PhoneProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiRoute</span> <span class="keyword">implements</span> <span class="title">RouteProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei route send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei route receive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiRoute</span> <span class="keyword">implements</span> <span class="title">RouteProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi route send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi route receive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建超级工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">RouteProduct <span class="title">routeProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建每个产品对应的工厂类，超级工厂的子类负责创建产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteProduct <span class="title">routeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiRoute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteProduct <span class="title">routeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiRoute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消费者去消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HuaweiFactory huaweiFactory = <span class="keyword">new</span> HuaweiFactory();</span><br><span class="line">        PhoneProduct huaweiPhone = huaweiFactory.phoneProduct();</span><br><span class="line">        huaweiPhone.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;​        工厂模式在设计模式中属于创建者模式，工厂模式的目的是不让创建对象时不把创建逻辑暴露给客户端，并且通过一个统一接口来指向创建对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://thisiswilli.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://thisiswilli.cn/tags/Java/"/>
    
      <category term="设计模式" scheme="https://thisiswilli.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之ThreadPool简介</title>
    <link href="https://thisiswilli.cn/2020/03/03/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadPool%E7%AE%80%E4%BB%8B/"/>
    <id>https://thisiswilli.cn/2020/03/03/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadPool%E7%AE%80%E4%BB%8B/</id>
    <published>2020-03-03T12:04:44.000Z</published>
    <updated>2020-03-04T12:03:17.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><h2 id="需要了解的相关接口或类"><a href="#需要了解的相关接口或类" class="headerlink" title="需要了解的相关接口或类"></a>需要了解的相关接口或类</h2><a id="more"></a><p>首先，ThreadPool有关的接口或类的继承图如下</p><p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/threadpool_9.png" alt=""></p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>顶级接口，调用实现了Runnable接口的命令</p><p>Executors的存在是为了避免开发者显式的去创建一个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor是一个线程框架</p><p>简单实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyExecutor().execute(()-&gt;&#123;</span><br><span class="line">          <span class="comment">// 实现了run方法</span></span><br><span class="line">            System.out.println(<span class="string">"hello command"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新起一个线程去调用这个方法</span></span><br><span class="line"><span class="comment">//        new Thread(command).run();</span></span><br><span class="line">        <span class="comment">// 调用run方法</span></span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><pre><code>该接口继承自Executor接口，扩展了Executor接口，添加了shutdown、shutdownAll、submit、invokeAll等一系列对线程的操作方法，该接口比较重要，在使用线程池框架的时候，经常用到该接口。</code></pre><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>线程池的工厂类，用工厂方法初始化各种线程池，一下为部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="meta">@param</span> nThreads the number of threads in the pool</span><br><span class="line"> * <span class="meta">@return</span> the newly created thread pool</span><br><span class="line"> * <span class="meta">@throws</span> IllegalArgumentException <span class="keyword">if</span> &#123;<span class="meta">@code</span> nThreads &lt;= <span class="number">0</span>&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* creates a <span class="keyword">new</span> thread</span><br><span class="line"> * <span class="meta">@return</span> a newly created scheduled thread pool</span><br><span class="line"> * <span class="meta">@throws</span> IllegalArgumentException <span class="keyword">if</span> &#123;<span class="meta">@code</span> corePoolSize &lt; <span class="number">0</span>&#125;</span><br><span class="line"> * <span class="meta">@throws</span> NullPointerException <span class="keyword">if</span> threadFactory is <span class="keyword">null</span></span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><pre><code>Callable接口与Runnable接口类似，实现了Callable接口与Runnable接口的类都是可以被其他线程执行的任务。但是Callable与Runnable有几点不同：</code></pre><ul><li>Callable规定的方法是call()，而Runnable规定的方法是run()。</li><li>Callable的任务执行后可返回值，  运行Callable的方法可返回一个Future对象，Future表示这个线程的执行结果。而Runnable的任务是不能返回值的。</li><li>call()方法可抛出异常，而run()方法是不能抛出异常的。</li></ul><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>future接口中有3个方法，2个属性</p><ul><li><p><code>boolean cancel(boolean mayInterruptIfRunning);</code></p><p>该方法用于取消任务的执行</p></li><li><p><code>boolean isCancelled();</code></p><p>判断任务在完成之前被停止</p></li><li><p><code>boolean isDone()</code></p><p>无论是如果任务正常终止、异常或取消，都将返回true</p></li><li><p><code>V get() throws InterruptedException, ExecutionException</code></p><p>等待任务结束，并获取任务结束的返回值</p></li><li><p><code>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;</code></p><p>等待任务结束，在timeout的时间内获取任务的返回值，如果超时则不再等待</p></li></ul><h2 id="多种线程池"><a href="#多种线程池" class="headerlink" title="多种线程池"></a>多种线程池</h2><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>容量大小固定的线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将主线程阻塞</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为，可见线程池最大容量为5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Running, pool size &#x3D; 0, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 0]</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-5</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-5</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Running, pool size &#x3D; 5, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 10]</span><br></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>可缓存的线程池，来一个任务就创建一个线程，工作线程如果空闲超过一定时间，会被回收。默认为60s，以下为Executors工厂类中关于newCachedThreadPool()创建方式以及ThreadPoolExecutors构造器的源码，可见线程空闲时间超过60s，就会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来用代码进行测试，编写如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="comment">// 线程会被回收</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">70</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size &#x3D; 0, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 0]</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size &#x3D; 2, active threads &#x3D; 2, queued tasks &#x3D; 0, completed tasks &#x3D; 0]</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-1</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size &#x3D; 0, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 2]</span><br></pre></td></tr></table></figure><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>这个线程池容量为1，没轮到的工作在队列中等待，如果有任务需要从前往后顺序执行，可以使用SingleThreadExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 任务如果是前后顺序执行的，那么选择SingleThreadPool</span></span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executors$FinalizableDelegatedExecutorService@1d44bcfa</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">java.util.concurrent.Executors$FinalizableDelegatedExecutorService@1d44bcfa</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>定时器线程，线程可以复用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 定时器线程池，线程可以服用，以固定频率执行一个任务</span></span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">        service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">java.util.concurrent.ScheduledThreadPoolExecutor@3feba861[Running, pool size &#x3D; 4, active threads &#x3D; 0, queued tasks &#x3D; 1, completed tasks &#x3D; 7]</span><br></pre></td></tr></table></figure><h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p>工作窃取线程池，如果10个任务由4个线程来完成，那么并不一定4个线程都会被均匀分配任务，这就意味着，如果线程1忙完了那么他就可能会抢在剩下3个线程之前去接着执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkingStealingPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务分配不均匀的场景</span></span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">R</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newWorkStealingPool(<span class="number">4</span>);</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1处理的任务时间比任务2长</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">3000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">1000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">4000</span>));</span><br><span class="line">        <span class="comment">// 等4个线程都分配到任务执行之后，线程2最先完成任务，并抢占剩下的任务去执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">5000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">6000</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，可见线程2最先完成任务，并抢占剩下的任务执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br></pre></td></tr></table></figure><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><pre><code>ForkJoinPool任务的执行逻辑有点类似于排序中的归并排序，以及大数据处理中的mapreduce的过程，ForkJoinPool的运行逻辑图如下所示</code></pre><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/ForkJoin%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h4 id="ForkJoinPool中的模块"><a href="#ForkJoinPool中的模块" class="headerlink" title="ForkJoinPool中的模块"></a>ForkJoinPool中的模块</h4><ul><li><p>任务对象ForkJoinTask，这是一个抽象类，在实际使用中，我们一般使用它的子类来创建ForkJoinPool的任务对象</p><ul><li><p>RecursiveTask，重写该类中的compute方法，自定义所需的task任务，该task任务可以返回task的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the result of the computation</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">compute</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>RecursiveAction，与RecursiveTask类似，但是RecursiveAction中的compute方法不带返回值，不能返回task的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>执行Fork/Join任务的线程: <code>ForkJoinWorkerThread</code>，这个类中维护着一个任务队列workQueue，工作线程优先处理来自自身队列的任务(LIFO或FIFO顺序，参数 mode 决定)，然后以FIFO的顺序随机窃取其他队列中的任务，这跟WorkStealingPool原理是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a ForkJoinWorkerThread operating in the given pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pool the pool this thread works in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if pool is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">        <span class="keyword">this</span>.pool = pool;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Version for InnocuousForkJoinWorkerThread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ForkJoinWorkerThread(ForkJoinPool pool, ThreadGroup threadGroup,</span><br><span class="line">                         AccessControlContext acc) &#123;</span><br><span class="line">        <span class="keyword">super</span>(threadGroup, <span class="keyword">null</span>, <span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, INHERITEDACCESSCONTROLCONTEXT, acc);</span><br><span class="line">        eraseThreadLocals(); <span class="comment">// clear before registering</span></span><br><span class="line">        <span class="keyword">this</span>.pool = pool;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>线程池: <code>ForkJoinPool</code>，线程池维护着管理所有的<code>ForkJoinWorkerThread</code></li></ul><h4 id="ForkJoinPool的应用"><a href="#ForkJoinPool的应用" class="headerlink" title="ForkJoinPool的应用"></a>ForkJoinPool的应用</h4><p>使用计算40000个随机数为例，来演示ForkJoinPool的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"单线程计算数组和为"</span> + Arrays.stream(nums).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask1</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTask1</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start &lt;= MAX_NUM)&#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"from "</span> + start + <span class="string">"to "</span> + end + <span class="string">"="</span> + sum);</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">                AddTask1 subTask1 = <span class="keyword">new</span> AddTask1(start, mid);</span><br><span class="line">                AddTask1 subTask2 = <span class="keyword">new</span> AddTask1(mid, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask1 task1 = <span class="keyword">new</span> AddTask1(<span class="number">0</span>, nums.length);</span><br><span class="line">        pool.execute(task1);</span><br><span class="line">        Long result = task1.join();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">单线程计算数组和为49475235</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">多线程计算数组和为49475235</span><br></pre></td></tr></table></figure><h2 id="线程池的应用"><a href="#线程池的应用" class="headerlink" title="线程池的应用"></a>线程池的应用</h2><h3 id="利用线程池进行并行计算"><a href="#利用线程池进行并行计算" class="headerlink" title="利用线程池进行并行计算"></a>利用线程池进行并行计算</h3><pre><code>以计算1～400000这几个数中的质数个数为例，分别用单线程和多线程进行计算，比较执行任务的时间为了在每个线程执行完毕之后获得运行结果，我们需要使用submit()方法提交任务，通过返回的Future来获取每个list的数据或者大小</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelCompute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        List&lt;Integer&gt; result = getPrime(<span class="number">1</span>, <span class="number">4000000</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"单线程耗时"</span> + (end - start) + <span class="string">"ms "</span> + <span class="string">"质数个数为"</span> + result.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cpuCoreNum = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class="line"></span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f1 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">1</span>, <span class="number">1000000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f2 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">1000001</span>, <span class="number">2000000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f3 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">2000001</span>, <span class="number">3000000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f4 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">3000001</span>, <span class="number">4000000</span>));</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> size1 = f1.get().size();</span><br><span class="line">        <span class="keyword">int</span> size2 = f2.get().size();</span><br><span class="line">        <span class="keyword">int</span> size3 = f3.get().size();</span><br><span class="line">        <span class="keyword">int</span> size4 = f4.get().size();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"多线程耗时"</span> + (end - start) + <span class="string">"ms "</span> + <span class="string">"质数个数为"</span> + (size1 + size2 + size3 + size4));</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="comment">/*&lt;= num*/</span>&lt;= Math.sqrt(num) + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startPos, endPos;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> startPos, <span class="keyword">int</span> endPos)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = startPos;</span><br><span class="line">            <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; result = getPrime(startPos, endPos);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i))&#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单线程耗时3414ms 质数个数为2000000</span><br><span class="line">多线程耗时1133ms 质数个数为2000000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadPool&quot;&gt;&lt;a href=&quot;#ThreadPool&quot; class=&quot;headerlink&quot; title=&quot;ThreadPool&quot;&gt;&lt;/a&gt;ThreadPool&lt;/h1&gt;&lt;h2 id=&quot;需要了解的相关接口或类&quot;&gt;&lt;a href=&quot;#需要了解的相关接口或类&quot; class=&quot;headerlink&quot; title=&quot;需要了解的相关接口或类&quot;&gt;&lt;/a&gt;需要了解的相关接口或类&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Standalone模式搭建</title>
    <link href="https://thisiswilli.cn/2020/02/26/Standalone%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/"/>
    <id>https://thisiswilli.cn/2020/02/26/Standalone%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/</id>
    <published>2020-02-26T13:01:49.000Z</published>
    <updated>2020-02-26T13:09:13.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark-Standalone模式"><a href="#Spark-Standalone模式" class="headerlink" title="Spark Standalone模式"></a>Spark Standalone模式</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装配置jdk8"><a href="#安装配置jdk8" class="headerlink" title="安装配置jdk8"></a>安装配置jdk8</h3><ul><li><p>检查jdk版本</p></li><li><p>上传jdk8和Spark2.3.1到node01</p></li><li><p><code>[root@node01 software]# tar -zxvf ./jdk-8u181-linux-x64.tar.gz</code></p></li><li><p>删除jdk安装包<code>[root@node01 software]# rm -rf ./jdk-8u181-linux-x64.tar.gz</code></p></li><li><p>在node01上配置jdk，注意PATH必须放到export jdk前面，不然会导致还是识别老版本的jdk</p></li></ul><a id="more"></a>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_67</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;root&#x2F;software&#x2F;jdk1.8.0_181</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;opt&#x2F;sxt&#x2F;hadoop-2.6.5</span><br><span class="line">export HBASE_HOME&#x3D;&#x2F;root&#x2F;hbase</span><br><span class="line">export PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin:$HBASE_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><ul><li><p>在其他节点上也配置jdk8</p></li><li><p>发送jdk8到其他节点上<code>[root@node01 software]# scp -r ./jdk1.8.0_181/ node02:</code>pwd``</p></li><li><p>每个node上都要<code>source /etc/profile</code></p></li><li><p>直接解压的java需要覆盖软连接路径，软连接路径在<code>/usr/bin</code>下，因为spark默认会在usr/bin目录下寻找java</p></li><li><p>改变java的软连接<code>ln -sf /root/software/jdk1.8.0_181/bin/java  /usr/bin/java</code></p></li><li><p>配置hadoop配置文件中的java<code>[root@node01 hadoop]# vim hadoop-env.sh</code></p></li><li><p>每个节点都修改文件<code>export JAVA_HOME=/root/software/jdk1.8.0_181/bin/java</code></p></li><li><p>勘误：应该是改成<code>export JAVA_HOME=/root/software/jdk1.8.0_181</code><strong>不然hadoop集群起不来</strong></p></li></ul><h3 id="安装Spark"><a href="#安装Spark" class="headerlink" title="安装Spark"></a>安装Spark</h3><ul><li><p>解压<code>[root@node01 software]# tar -zxvf ./spark-2.3.1-bin-hadoop2.6.tgz</code></p></li><li><p>改名<code>[root@node01 software]# mv ./spark-2.3.1-bin-hadoop2.6.tgz  ./spark-2.3.1</code></p></li><li><p>删除安装包<code>[root@node01 software]# rm -rf ./spark-2.3.1-bin-hadoop2.6</code></p></li><li><p>先配置spark的slave，先复制一份<code>[root@node01 conf]# cp slaves.template slaves</code></p></li><li><p><code>[root@node01 conf]# vim slaves</code>添加node02，node03</p></li><li><p><code>[root@node01 conf]# cp spark-env.sh.template spark-env.sh</code></p></li><li><p><code>[root@node01 conf]# vim spark-env.sh</code>，配置相关配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_MASTER_HOST&#x3D;node01</span><br><span class="line">export SPARK_MASTER_PORT&#x3D;7077</span><br><span class="line">export SPARK_WORKER_CORES&#x3D;2</span><br><span class="line">export SPARK_WORKER_MEMORY&#x3D;3g</span><br></pre></td></tr></table></figure></li><li><p>发送spark文件夹到node02，node03节点<code>[root@node01 sbin]# scp -r ./spark-2.3.1/ node03:</code>pwd```</p></li></ul><h3 id="安装Spark客户端"><a href="#安装Spark客户端" class="headerlink" title="安装Spark客户端"></a>安装Spark客户端</h3><ul><li><code>[root@node04 software]# mkdir spark</code></li><li><code>[root@node01 software]# scp -r spark-2.3.1/ node04:</code>pwd``</li><li><code>[root@node04 spark-2.3.1]# cd conf/</code></li><li><code>[root@node04 conf]# rm -f ./slaves</code></li><li><code>[root@node04 conf]# rm -f ./spark-env.sh</code></li></ul><h2 id="对Spark集群进行操作"><a href="#对Spark集群进行操作" class="headerlink" title="对Spark集群进行操作"></a>对Spark集群进行操作</h2><h3 id="运行Spark集群"><a href="#运行Spark集群" class="headerlink" title="运行Spark集群"></a>运行Spark集群</h3><ul><li><p>启动spark集群，首先要进入<code>/root/software/spark-2.3.1/sbin</code>目录下，再<code>[root@node01 sbin]# ./start-all.sh</code></p></li><li><p>进入web端页面查看<code>node01:8080</code></p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Spark/sparkweb%E9%A1%B5%E9%9D%A2%E6%9F%A5%E7%9C%8B.png" alt=""></p></li><li><p>关闭集群<code>[root@node01 sbin]# ./stop-all.sh</code></p></li></ul><h3 id="Standalone模式提交任务"><a href="#Standalone模式提交任务" class="headerlink" title="Standalone模式提交任务"></a>Standalone模式提交任务</h3><ul><li>启动集群</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spark-Standalone模式&quot;&gt;&lt;a href=&quot;#Spark-Standalone模式&quot; class=&quot;headerlink&quot; title=&quot;Spark Standalone模式&quot;&gt;&lt;/a&gt;Spark Standalone模式&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;安装配置jdk8&quot;&gt;&lt;a href=&quot;#安装配置jdk8&quot; class=&quot;headerlink&quot; title=&quot;安装配置jdk8&quot;&gt;&lt;/a&gt;安装配置jdk8&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检查jdk版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上传jdk8和Spark2.3.1到node01&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;[root@node01 software]# tar -zxvf ./jdk-8u181-linux-x64.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除jdk安装包&lt;code&gt;[root@node01 software]# rm -rf ./jdk-8u181-linux-x64.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在node01上配置jdk，注意PATH必须放到export jdk前面，不然会导致还是识别老版本的jdk&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Spark" scheme="https://thisiswilli.cn/categories/Spark/"/>
    
    
      <category term="Spark" scheme="https://thisiswilli.cn/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>idea远程连接hadoop进行文件操作</title>
    <link href="https://thisiswilli.cn/2019/02/26/idea%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5hadoop%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://thisiswilli.cn/2019/02/26/idea%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5hadoop%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2019-02-26T11:45:59.000Z</published>
    <updated>2020-02-26T13:00:48.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="idea远程连接hadoop进行文件操作"><a href="#idea远程连接hadoop进行文件操作" class="headerlink" title="idea远程连接hadoop进行文件操作"></a>idea远程连接hadoop进行文件操作</h1><p>部署完高可用集群之后，尝试idea远程连接hadoop进行操作</p><h2 id="配置windows中的hadoop环境"><a href="#配置windows中的hadoop环境" class="headerlink" title="配置windows中的hadoop环境"></a>配置windows中的hadoop环境</h2><ul><li><p>下载hadoop2.6.5到windows中并放在一个纯英文目录下</p></li><li><p>配置环境变量，先系统变量中创建HADOOP_HOME</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAHADOOP_HOME.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAHADOOP_HOME.PNG"></p></li><li><p>创建HADOOP_USER_NAME，名称为集群中的登录名称</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAHADOOP_USER_NAME.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAHADOOP_USER_NAME.PNG"></p></li><li><p>在系统变量的Path中添加%HADOOP_HOME%/bin</p></li><li><p>将hadoop.dll添加到C:\Windows\System32文件夹下</p></li><li><p>在命令行中输入hdfs和hadoop，检测是否安装成功</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/hadoop%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/hadoop%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.PNG"></p></li></ul><h2 id="在idea中配置hadoop"><a href="#在idea中配置hadoop" class="headerlink" title="在idea中配置hadoop"></a>在idea中配置hadoop</h2><ul><li><p>首先下载插件(再次感谢作者)<a href="https://github.com/fangyuzhong2016/HadoopIntellijPlugin，直接clone下来即可，注意项目中所要求的配置信息" target="_blank" rel="noopener">https://github.com/fangyuzhong2016/HadoopIntellijPlugin，直接clone下来即可，注意项目中所要求的配置信息</a></p></li><li><p>idea中创建maven项目</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAmaven%E5%B7%A5%E7%A8%8B.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAmaven%E5%B7%A5%E7%A8%8B.PNG"></p></li><li><p>工程创建完成之后，File-&gt;Settings-Plugin-&gt;点击右上角的设置-&gt;Install plugin from disk</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%AE%89%E8%A3%85plugins.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%AE%89%E8%A3%85plugins.PNG"></p></li><li><p>重启idea，菜单栏中会出现hadoop选项</p></li></ul><h2 id="连接hadoop，进行文件操作"><a href="#连接hadoop，进行文件操作" class="headerlink" title="连接hadoop，进行文件操作"></a>连接hadoop，进行文件操作</h2><ul><li><p>首先开启集群，先<code>zkServer.sh start</code>开启zookeeper，再<code>start-dfs.sh</code>开启全部节点，在配置节点前首先进入node01:50070查看node01和node02的状态。</p></li><li><p>点击idea上方菜单栏中的hadoop进入设置</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E8%AE%BE%E7%BD%AEhadoop%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E8%AE%BE%E7%BD%AEhadoop%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.PNG"></p></li><li><p>确定之后左边会出现hadoop</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/hadoop%E4%BE%A7%E8%BE%B9%E6%A0%8F.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/hadoop%E4%BE%A7%E8%BE%B9%E6%A0%8F.PNG"></p></li><li><p>进行文件操作，代码具体如下，可用junit进行调试，并在hadoop插件中查看hdfs文件系统</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sxt.hdfs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configured;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \* Project: hadoop</span></span><br><span class="line"><span class="comment"> * \* Package: com.sxt.hdfs.test</span></span><br><span class="line"><span class="comment"> * \* Author: Hoodie_Willi</span></span><br><span class="line"><span class="comment"> * \* Date: 2019-07-29 20:36:22</span></span><br><span class="line"><span class="comment"> * \* Description:</span></span><br><span class="line"><span class="comment"> * \</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">null</span>;</span><br><span class="line">    FileSystem fs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conn</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        fs = FileSystem.get(conf);</span><br><span class="line">        <span class="comment">//System.out.println("success");</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = <span class="keyword">new</span> Path(<span class="string">"/mytemp"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fs.exists(path))&#123;</span><br><span class="line">            fs.delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.mkdirs(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//文件上传路径</span></span><br><span class="line">        Path path = <span class="keyword">new</span> Path(<span class="string">"/mytemp/haha.txt"</span>);</span><br><span class="line">        FSDataOutputStream fdos = fs.create(path);</span><br><span class="line">        <span class="comment">//获取磁盘文件</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\IdeaProject\\hadoop\\src\\files\\hello.txt"</span>));</span><br><span class="line">        IOUtils.copyBytes(is, fdos, conf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Path f = <span class="keyword">new</span> Path(<span class="string">"/user/root/test.txt"</span>);</span><br><span class="line">        FileStatus file = fs.getFileStatus(f);</span><br><span class="line"><span class="comment">//        BlockLocation[] blks = fs.getFileBlockLocations(file,0, file.getLen());</span></span><br><span class="line"><span class="comment">//        for (BlockLocation blk : blks)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(blk);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        FSDataInputStream fdis = fs.open(f); <span class="comment">// fileinputstream</span></span><br><span class="line">        fdis.seek(<span class="number">1048576</span>);</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;idea远程连接hadoop进行文件操作&quot;&gt;&lt;a href=&quot;#idea远程连接hadoop进行文件操作&quot; class=&quot;headerlink&quot; title=&quot;idea远程连接hadoop进行文件操作&quot;&gt;&lt;/a&gt;idea远程连接hadoop进行文件操作&lt;/h1&gt;&lt;p&gt;部署完高可用集群之后，尝试idea远程连接hadoop进行操作&lt;/p&gt;
&lt;h2 id=&quot;配置windows中的hadoop环境&quot;&gt;&lt;a href=&quot;#配置windows中的hadoop环境&quot; class=&quot;headerlink&quot; title=&quot;配置windows中的hadoop环境&quot;&gt;&lt;/a&gt;配置windows中的hadoop环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下载hadoop2.6.5到windows中并放在一个纯英文目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置环境变量，先系统变量中创建HADOOP_HOME&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="https://thisiswilli.cn/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://thisiswilli.cn/tags/Hadoop/"/>
    
  </entry>
  
</feed>
