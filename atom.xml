<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ThisisWilli</title>
  
  <subtitle>玉不琢，不成器</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thisiswilli.cn/"/>
  <updated>2020-03-10T11:22:34.561Z</updated>
  <id>https://thisiswilli.cn/</id>
  
  <author>
    <name>Willi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://thisiswilli.cn/2020/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://thisiswilli.cn/2020/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-10T11:18:28.000Z</published>
    <updated>2020-03-10T11:22:34.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>​        在单例模式使得一个类的对象成为该类所在系统的唯一实例，单例模式适合用于需要重复创建的类，比如配置文件类。单例模式能够减少系统内存开销，降低GC压力。</p><a id="more"></a><h3 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式有以下几点特点</p><ul><li>在类加载时就创建对象，即在类中将对象定义成static类型的类变量，跟随类一起加载，这种方式类似于<strong>空间换时间</strong></li><li>将构造器私有，让别的类不能创建对象</li><li>提供一个全局访问点，即提供一个public的以类自身为返回值的方法</li><li><strong>懒汉式是线程安全的</strong></li></ul><p>代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungryMode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在类加载时直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungryMode hungryMode = <span class="keyword">new</span> HungryMode();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungryMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungryMode <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungryMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hungry mode"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HungryMode.getInstance().say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>懒汉式具有以下几个特点</p><ul><li>懒汉式在第一次使用时才进行加载，这样在起初能够减少内存的占用，但是会导致第一次使用类时加载速度较慢</li><li>懒汉模式是以时间换空间</li><li>懒汉模式存在线程不安全的风险</li></ul><p>代码实现</p><h5 id="不考虑线程安全的简单实现"><a href="#不考虑线程安全的简单实现" class="headerlink" title="不考虑线程安全的简单实现"></a>不考虑线程安全的简单实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMode lazyMode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMode</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyMode <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazyMode = <span class="keyword">new</span> LazyMode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加一把锁"><a href="#加一把锁" class="headerlink" title="加一把锁"></a>加一把锁</h5><p>​        上面这种情况，如果多线程访问，可能会导致重复创建对象的情况出现，针对这种情况，可以在getInstance方法上加一把锁，这种方式实现很简单，但是每次调用getIntance方法拿到实例对象时，都需要拿到锁，可能会造成线程阻塞的情况出现，效率不高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModeSingleLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyModeSingleLock lazyModeSingleLock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyModeSingleLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  LazyModeSingleLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyModeSingleLock == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazyModeSingleLock = <span class="keyword">new</span> LazyModeSingleLock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyModeSingleLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加两把锁"><a href="#加两把锁" class="headerlink" title="加两把锁"></a>加两把锁</h5><p>解释一下为什么需要使用volatile修饰LazyModeDCL实例</p><ul><li><p>防止指令重排序</p><p>创建一个对象是一个非原子操作，创建一个对象分为一下几个步骤</p><ul><li>开辟内存空间–a</li><li>调用构造器创建对象–b</li><li>返回地址给对象引用–c</li></ul><p>指令重排序之后可能会出现a-&gt;c-&gt;b的执行顺序，线程一执行了重排序之后的代码返回了，对象地址的引用到主内存中，线程一释放了锁，但是线程二拿到锁之后，直接判定lazyModeDCL对象不为空，那么线程二拿到的很可能是还在初始化的一个对象。</p><p>Ps：但是有一种说法是，执行synchronized代码块中代码会等对象创建完之后再释放锁，所以上面的说法有不成立了。。。先留一个坑，等研究透synchronized再来填坑！</p><p><img src="https://pic1.zhimg.com/50/v2-99efda8df0ea883f1be403311eb4d824_hd.jpg" alt=""></p></li><li><p>保证可见性</p><p>如果线程一在自己的工作内存中创建了LazyModeDCL实例，释放了锁，但是还没有将结果同步到主内存中，这样会导致线程二在拿到了锁之后又创建了一个对象，如果使用volatile，就能让线程二中LazyModeDCL的缓存行失效，重新去主存中读取数据</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModeDCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyModeDCL lazyModeDCL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyModeDCL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyModeDCL <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyModeDCL == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyModeDCL<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyModeDCL == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyModeDCL = <span class="keyword">new</span> LazyModeDCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyModeDCL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用静态内部类"><a href="#使用静态内部类" class="headerlink" title="使用静态内部类"></a>使用静态内部类</h5><p>静态内部类的加载机制属于被动引用的行列，即在外部类初始化时，静态内部类如果没有被使用，就不会主动加载，静态内部类的方式类似于饿汉模式，也是线程安全的，但是使用这种方式将无法传参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModeStaticClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyModeStaticClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">setInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> LazyModeStaticClass INSTANCE = <span class="keyword">new</span> LazyModeStaticClass();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyModeStaticClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> setInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingle &#123;</span><br><span class="line">    <span class="comment">// INSTANCE;</span></span><br><span class="line">  EnumSingle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(EnumSingle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;p&gt;​        在单例模式使得一个类的对象成为该类所在系统的唯一实例，单例模式适合用于需要重复创建的类，比如配置文件类。单例模式能够减少系统内存开销，降低GC压力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://thisiswilli.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="[object Object]" scheme="https://thisiswilli.cn/tags/object-Object/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式和抽象工厂模式</title>
    <link href="https://thisiswilli.cn/2020/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://thisiswilli.cn/2020/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-09T14:32:44.000Z</published>
    <updated>2020-03-10T11:21:02.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>​        工厂模式在设计模式中属于创建者模式，工厂模式的目的是不让创建对象时不把创建逻辑暴露给客户端，并且通过一个统一接口来指向创建对象</p><a id="more"></a><h3 id="核心本质"><a href="#核心本质" class="headerlink" title="核心本质"></a>核心本质</h3><ul><li><strong>实例化对象不是用new而使用工厂方法代替</strong></li><li>将选择实现类，创建对象统一管理和控制，从而将调用者与使用者解耦</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>​        简单工厂模式又称静态工厂模式，简单工厂创建一个工厂类，根据客户端传入的不同参数，来创建不同的产品(类)。而这些被创建的类都实现同一个接口。简单工厂模式适合在产品类较少的环境下使用，因为这样能够避免工厂类中的代码逻辑过于复杂。</p><h4 id="简单工厂所包含的角色"><a href="#简单工厂所包含的角色" class="headerlink" title="简单工厂所包含的角色"></a>简单工厂所包含的角色</h4><ul><li>产品接口：担任简单工厂所创建产品的父类，用interface实现</li><li>产品类：简单工厂所创建的产品实例，都实现了产品接口</li><li>工厂类：核心类，包含着产品类的创建逻辑，客户端直接与工厂类交互来获得新产品</li></ul><h4 id="简单工厂的优缺点"><a href="#简单工厂的优缺点" class="headerlink" title="简单工厂的优缺点"></a>简单工厂的优缺点</h4><p>优点：</p><ul><li>工厂类能够使产品的创建与产品的消费实现解耦，让客户端不需要了解产品是怎么创建的，只需负责消费即可，如果没有工厂类，那么客户端在获取一个产品类的时候就要先去创建产品，客户端同时负责创建和消费产品，这样代码之间过于耦合。</li><li>客户端不用掌握产品类的具体信息，只要根据一些必要参数，就能让工厂类完成所需类的创建</li><li>在工厂模式下，产品的添加与删除都不用修改客户端的代码，提高了系统的灵活性</li></ul><p>缺点：</p><ul><li>系统扩展较为复杂，如果需要添加一个新的产品，就需新创建一个产品类，并需要更改工厂类中的代码，如果产品很多，会使得工厂类中的代码逻辑较为复杂，难以维护</li></ul><h4 id="简单工厂的实现"><a href="#简单工厂的实现" class="headerlink" title="简单工厂的实现"></a>简单工厂的实现</h4><p>uml图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%9B%BE.png" alt=""></p><ul><li><p>首先创建一个车的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建两个产品类，并实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"特斯拉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLing</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"五菱宏光"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建工厂类，并用静态方法完成对产品类的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Car <span class="title">buyCar</span><span class="params">(String car)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (car.equals(<span class="string">"WuLing"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WuLing();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (car.equals(<span class="string">"Tesla"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消费者，如下代码所示，消费者如果要购买Tesla，他不需要了解Tesla的具体信息，只需要创建一个工厂，并告诉工厂，他需要购买一辆特斯拉，也就是传入Tesla字符串，就能得到一个Tesla实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car tesla = <span class="keyword">new</span> CarFactory().buyCar(<span class="string">"Tesla"</span>);</span><br><span class="line">        tesla.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>​        在工厂模式下，每一样产品都有自己对应的生产工厂，客户端只需要知道所需产品的工厂名称，即可通过创建工厂来获得产品</p><h4 id="工厂模式的角色"><a href="#工厂模式的角色" class="headerlink" title="工厂模式的角色"></a>工厂模式的角色</h4><ul><li>工厂接口：每个产品工厂的父类，定义每个产品工厂的功能</li><li>子类工厂：每个产品所对应的工厂，负责生产对应的产品</li><li>产品类</li></ul><h4 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h4><p>优点：</p><ul><li>客户端不需要知道类的具体信息，只需要知道类对应的工厂，然后创建该工厂，就能获得产品</li><li>扩展性好，新添加一样产品，只需新创建一个该产品的工厂类即可。</li><li>屏蔽产品的具体实现，客户端只关心产品的接口。</li></ul><p>缺点</p><ul><li>如果添加的产品过多，可能会使类的个数成倍增长，增加了系统的复杂度</li></ul><h4 id="工厂模式的实现"><a href="#工厂模式的实现" class="headerlink" title="工厂模式的实现"></a>工厂模式的实现</h4><p>uml图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8Fuml%E5%9B%BE.png" alt=""></p><ul><li><p>创建实体类的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"特斯拉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLing</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"五菱宏光"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建工厂类的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建每个床品对应的工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeslaCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLingFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WuLing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消费者来消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car wuling = <span class="keyword">new</span> WuLingFactory().getCar();</span><br><span class="line">        Car tesla = <span class="keyword">new</span> TeslaCarFactory().getCar();</span><br><span class="line">        wuling.name();</span><br><span class="line">        tesla.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="抽像工厂模式"><a href="#抽像工厂模式" class="headerlink" title="抽像工厂模式"></a>抽像工厂模式</h3><p>​        在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h4 id="抽象工厂的角色"><a href="#抽象工厂的角色" class="headerlink" title="抽象工厂的角色"></a>抽象工厂的角色</h4><ul><li>超级工厂：所有工厂的抽象化实现，超级工厂生产抽象的产品，具体产品的生产交给子类去做</li><li>产品的抽象类</li><li>工厂类</li><li>产品类</li></ul><h4 id="抽象工厂的优缺点"><a href="#抽象工厂的优缺点" class="headerlink" title="抽象工厂的优缺点"></a>抽象工厂的优缺点</h4><p>优点：</p><ul><li>客户端不需要知道什么被生产了，只需接受生产类给他生产的产品</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的工厂和产品族很方便，无需修改已有系统，符合开闭原则，比如下面实现的例子，如果我要加一个苹果工厂的实例，只需要增加一个苹果工厂并实现超级工厂这个接口即可</li></ul><p>缺点：</p><ul><li>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，比如下面如果需要增加一个手表类，那么原来的代码很多地方都要修改。</li></ul><h4 id="抽象工厂的实现"><a href="#抽象工厂的实现" class="headerlink" title="抽象工厂的实现"></a>抽象工厂的实现</h4><p>uml图如下所示</p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/JavaFoundation/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82uml.png" alt=""></p><ul><li><p>首相创建两个抽象的产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RouteProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建两个抽象产品相应的产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title">PhoneProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiRoute</span> <span class="keyword">implements</span> <span class="title">RouteProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei route send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"huawei route receive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiRoute</span> <span class="keyword">implements</span> <span class="title">RouteProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi route send"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaomi route receive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建超级工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">RouteProduct <span class="title">routeProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建每个产品对应的工厂类，超级工厂的子类负责创建产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteProduct <span class="title">routeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiRoute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteProduct <span class="title">routeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiRoute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消费者去消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HuaweiFactory huaweiFactory = <span class="keyword">new</span> HuaweiFactory();</span><br><span class="line">        PhoneProduct huaweiPhone = huaweiFactory.phoneProduct();</span><br><span class="line">        huaweiPhone.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;​        工厂模式在设计模式中属于创建者模式，工厂模式的目的是不让创建对象时不把创建逻辑暴露给客户端，并且通过一个统一接口来指向创建对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://thisiswilli.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="[object Object]" scheme="https://thisiswilli.cn/tags/object-Object/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之ThreadPool简介</title>
    <link href="https://thisiswilli.cn/2020/03/03/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadPool%E7%AE%80%E4%BB%8B/"/>
    <id>https://thisiswilli.cn/2020/03/03/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadPool%E7%AE%80%E4%BB%8B/</id>
    <published>2020-03-03T12:04:44.000Z</published>
    <updated>2020-03-04T12:03:17.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><h2 id="需要了解的相关接口或类"><a href="#需要了解的相关接口或类" class="headerlink" title="需要了解的相关接口或类"></a>需要了解的相关接口或类</h2><a id="more"></a><p>首先，ThreadPool有关的接口或类的继承图如下</p><p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/threadpool_9.png" alt=""></p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>顶级接口，调用实现了Runnable接口的命令</p><p>Executors的存在是为了避免开发者显式的去创建一个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor是一个线程框架</p><p>简单实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyExecutor().execute(()-&gt;&#123;</span><br><span class="line">          <span class="comment">// 实现了run方法</span></span><br><span class="line">            System.out.println(<span class="string">"hello command"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新起一个线程去调用这个方法</span></span><br><span class="line"><span class="comment">//        new Thread(command).run();</span></span><br><span class="line">        <span class="comment">// 调用run方法</span></span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><pre><code>该接口继承自Executor接口，扩展了Executor接口，添加了shutdown、shutdownAll、submit、invokeAll等一系列对线程的操作方法，该接口比较重要，在使用线程池框架的时候，经常用到该接口。</code></pre><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>线程池的工厂类，用工厂方法初始化各种线程池，一下为部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="meta">@param</span> nThreads the number of threads in the pool</span><br><span class="line"> * <span class="meta">@return</span> the newly created thread pool</span><br><span class="line"> * <span class="meta">@throws</span> IllegalArgumentException <span class="keyword">if</span> &#123;<span class="meta">@code</span> nThreads &lt;= <span class="number">0</span>&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* creates a <span class="keyword">new</span> thread</span><br><span class="line"> * <span class="meta">@return</span> a newly created scheduled thread pool</span><br><span class="line"> * <span class="meta">@throws</span> IllegalArgumentException <span class="keyword">if</span> &#123;<span class="meta">@code</span> corePoolSize &lt; <span class="number">0</span>&#125;</span><br><span class="line"> * <span class="meta">@throws</span> NullPointerException <span class="keyword">if</span> threadFactory is <span class="keyword">null</span></span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><pre><code>Callable接口与Runnable接口类似，实现了Callable接口与Runnable接口的类都是可以被其他线程执行的任务。但是Callable与Runnable有几点不同：</code></pre><ul><li>Callable规定的方法是call()，而Runnable规定的方法是run()。</li><li>Callable的任务执行后可返回值，  运行Callable的方法可返回一个Future对象，Future表示这个线程的执行结果。而Runnable的任务是不能返回值的。</li><li>call()方法可抛出异常，而run()方法是不能抛出异常的。</li></ul><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>future接口中有3个方法，2个属性</p><ul><li><p><code>boolean cancel(boolean mayInterruptIfRunning);</code></p><p>该方法用于取消任务的执行</p></li><li><p><code>boolean isCancelled();</code></p><p>判断任务在完成之前被停止</p></li><li><p><code>boolean isDone()</code></p><p>无论是如果任务正常终止、异常或取消，都将返回true</p></li><li><p><code>V get() throws InterruptedException, ExecutionException</code></p><p>等待任务结束，并获取任务结束的返回值</p></li><li><p><code>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;</code></p><p>等待任务结束，在timeout的时间内获取任务的返回值，如果超时则不再等待</p></li></ul><h2 id="多种线程池"><a href="#多种线程池" class="headerlink" title="多种线程池"></a>多种线程池</h2><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>容量大小固定的线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将主线程阻塞</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为，可见线程池最大容量为5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Running, pool size &#x3D; 0, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 0]</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-5</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-5</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor@1d44bcfa[Running, pool size &#x3D; 5, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 10]</span><br></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>可缓存的线程池，来一个任务就创建一个线程，工作线程如果空闲超过一定时间，会被回收。默认为60s，以下为Executors工厂类中关于newCachedThreadPool()创建方式以及ThreadPoolExecutors构造器的源码，可见线程空闲时间超过60s，就会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来用代码进行测试，编写如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="comment">// 线程会被回收</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">70</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size &#x3D; 0, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 0]</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size &#x3D; 2, active threads &#x3D; 2, queued tasks &#x3D; 0, completed tasks &#x3D; 0]</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-1</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor@266474c2[Running, pool size &#x3D; 0, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 2]</span><br></pre></td></tr></table></figure><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>这个线程池容量为1，没轮到的工作在队列中等待，如果有任务需要从前往后顺序执行，可以使用SingleThreadExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 任务如果是前后顺序执行的，那么选择SingleThreadPool</span></span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executors$FinalizableDelegatedExecutorService@1d44bcfa</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">java.util.concurrent.Executors$FinalizableDelegatedExecutorService@1d44bcfa</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>定时器线程，线程可以复用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 定时器线程池，线程可以服用，以固定频率执行一个任务</span></span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">        service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">java.util.concurrent.ScheduledThreadPoolExecutor@3feba861[Running, pool size &#x3D; 4, active threads &#x3D; 0, queued tasks &#x3D; 1, completed tasks &#x3D; 7]</span><br></pre></td></tr></table></figure><h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p>工作窃取线程池，如果10个任务由4个线程来完成，那么并不一定4个线程都会被均匀分配任务，这就意味着，如果线程1忙完了那么他就可能会抢在剩下3个线程之前去接着执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkingStealingPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务分配不均匀的场景</span></span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">R</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newWorkStealingPool(<span class="number">4</span>);</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1处理的任务时间比任务2长</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">3000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">1000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">4000</span>));</span><br><span class="line">        <span class="comment">// 等4个线程都分配到任务执行之后，线程2最先完成任务，并抢占剩下的任务去执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">5000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> R(<span class="number">6000</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，可见线程2最先完成任务，并抢占剩下的任务执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br></pre></td></tr></table></figure><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><pre><code>ForkJoinPool任务的执行逻辑有点类似于排序中的归并排序，以及大数据处理中的mapreduce的过程，ForkJoinPool的运行逻辑图如下所示</code></pre><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/concurrency/ForkJoin%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h4 id="ForkJoinPool中的模块"><a href="#ForkJoinPool中的模块" class="headerlink" title="ForkJoinPool中的模块"></a>ForkJoinPool中的模块</h4><ul><li><p>任务对象ForkJoinTask，这是一个抽象类，在实际使用中，我们一般使用它的子类来创建ForkJoinPool的任务对象</p><ul><li><p>RecursiveTask，重写该类中的compute方法，自定义所需的task任务，该task任务可以返回task的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the result of the computation</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">compute</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>RecursiveAction，与RecursiveTask类似，但是RecursiveAction中的compute方法不带返回值，不能返回task的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>执行Fork/Join任务的线程: <code>ForkJoinWorkerThread</code>，这个类中维护着一个任务队列workQueue，工作线程优先处理来自自身队列的任务(LIFO或FIFO顺序，参数 mode 决定)，然后以FIFO的顺序随机窃取其他队列中的任务，这跟WorkStealingPool原理是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a ForkJoinWorkerThread operating in the given pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pool the pool this thread works in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if pool is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">        <span class="keyword">this</span>.pool = pool;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Version for InnocuousForkJoinWorkerThread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ForkJoinWorkerThread(ForkJoinPool pool, ThreadGroup threadGroup,</span><br><span class="line">                         AccessControlContext acc) &#123;</span><br><span class="line">        <span class="keyword">super</span>(threadGroup, <span class="keyword">null</span>, <span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, INHERITEDACCESSCONTROLCONTEXT, acc);</span><br><span class="line">        eraseThreadLocals(); <span class="comment">// clear before registering</span></span><br><span class="line">        <span class="keyword">this</span>.pool = pool;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>线程池: <code>ForkJoinPool</code>，线程池维护着管理所有的<code>ForkJoinWorkerThread</code></li></ul><h4 id="ForkJoinPool的应用"><a href="#ForkJoinPool的应用" class="headerlink" title="ForkJoinPool的应用"></a>ForkJoinPool的应用</h4><p>使用计算40000个随机数为例，来演示ForkJoinPool的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolStudy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"单线程计算数组和为"</span> + Arrays.stream(nums).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask1</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTask1</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start &lt;= MAX_NUM)&#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"from "</span> + start + <span class="string">"to "</span> + end + <span class="string">"="</span> + sum);</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">                AddTask1 subTask1 = <span class="keyword">new</span> AddTask1(start, mid);</span><br><span class="line">                AddTask1 subTask2 = <span class="keyword">new</span> AddTask1(mid, end);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask1 task1 = <span class="keyword">new</span> AddTask1(<span class="number">0</span>, nums.length);</span><br><span class="line">        pool.execute(task1);</span><br><span class="line">        Long result = task1.join();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">单线程计算数组和为49475235</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-1</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-3</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">ForkJoinPool-1-worker-0</span><br><span class="line">ForkJoinPool-1-worker-2</span><br><span class="line">多线程计算数组和为49475235</span><br></pre></td></tr></table></figure><h2 id="线程池的应用"><a href="#线程池的应用" class="headerlink" title="线程池的应用"></a>线程池的应用</h2><h3 id="利用线程池进行并行计算"><a href="#利用线程池进行并行计算" class="headerlink" title="利用线程池进行并行计算"></a>利用线程池进行并行计算</h3><pre><code>以计算1～400000这几个数中的质数个数为例，分别用单线程和多线程进行计算，比较执行任务的时间为了在每个线程执行完毕之后获得运行结果，我们需要使用submit()方法提交任务，通过返回的Future来获取每个list的数据或者大小</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelCompute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        List&lt;Integer&gt; result = getPrime(<span class="number">1</span>, <span class="number">4000000</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"单线程耗时"</span> + (end - start) + <span class="string">"ms "</span> + <span class="string">"质数个数为"</span> + result.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cpuCoreNum = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class="line"></span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f1 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">1</span>, <span class="number">1000000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f2 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">1000001</span>, <span class="number">2000000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f3 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">2000001</span>, <span class="number">3000000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; f4 = service.submit(<span class="keyword">new</span> MyTask(<span class="number">3000001</span>, <span class="number">4000000</span>));</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> size1 = f1.get().size();</span><br><span class="line">        <span class="keyword">int</span> size2 = f2.get().size();</span><br><span class="line">        <span class="keyword">int</span> size3 = f3.get().size();</span><br><span class="line">        <span class="keyword">int</span> size4 = f4.get().size();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"多线程耗时"</span> + (end - start) + <span class="string">"ms "</span> + <span class="string">"质数个数为"</span> + (size1 + size2 + size3 + size4));</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="comment">/*&lt;= num*/</span>&lt;= Math.sqrt(num) + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startPos, endPos;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> startPos, <span class="keyword">int</span> endPos)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = startPos;</span><br><span class="line">            <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; result = getPrime(startPos, endPos);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i))&#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单线程耗时3414ms 质数个数为2000000</span><br><span class="line">多线程耗时1133ms 质数个数为2000000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadPool&quot;&gt;&lt;a href=&quot;#ThreadPool&quot; class=&quot;headerlink&quot; title=&quot;ThreadPool&quot;&gt;&lt;/a&gt;ThreadPool&lt;/h1&gt;&lt;h2 id=&quot;需要了解的相关接口或类&quot;&gt;&lt;a href=&quot;#需要了解的相关接口或类&quot; class=&quot;headerlink&quot; title=&quot;需要了解的相关接口或类&quot;&gt;&lt;/a&gt;需要了解的相关接口或类&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://thisiswilli.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://thisiswilli.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Standalone模式搭建</title>
    <link href="https://thisiswilli.cn/2020/02/26/Standalone%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/"/>
    <id>https://thisiswilli.cn/2020/02/26/Standalone%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/</id>
    <published>2020-02-26T13:01:49.000Z</published>
    <updated>2020-02-26T13:09:13.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark-Standalone模式"><a href="#Spark-Standalone模式" class="headerlink" title="Spark Standalone模式"></a>Spark Standalone模式</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装配置jdk8"><a href="#安装配置jdk8" class="headerlink" title="安装配置jdk8"></a>安装配置jdk8</h3><ul><li><p>检查jdk版本</p></li><li><p>上传jdk8和Spark2.3.1到node01</p></li><li><p><code>[root@node01 software]# tar -zxvf ./jdk-8u181-linux-x64.tar.gz</code></p></li><li><p>删除jdk安装包<code>[root@node01 software]# rm -rf ./jdk-8u181-linux-x64.tar.gz</code></p></li><li><p>在node01上配置jdk，注意PATH必须放到export jdk前面，不然会导致还是识别老版本的jdk</p></li></ul><a id="more"></a>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_67</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;root&#x2F;software&#x2F;jdk1.8.0_181</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;opt&#x2F;sxt&#x2F;hadoop-2.6.5</span><br><span class="line">export HBASE_HOME&#x3D;&#x2F;root&#x2F;hbase</span><br><span class="line">export PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin:$HBASE_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><ul><li><p>在其他节点上也配置jdk8</p></li><li><p>发送jdk8到其他节点上<code>[root@node01 software]# scp -r ./jdk1.8.0_181/ node02:</code>pwd``</p></li><li><p>每个node上都要<code>source /etc/profile</code></p></li><li><p>直接解压的java需要覆盖软连接路径，软连接路径在<code>/usr/bin</code>下，因为spark默认会在usr/bin目录下寻找java</p></li><li><p>改变java的软连接<code>ln -sf /root/software/jdk1.8.0_181/bin/java  /usr/bin/java</code></p></li><li><p>配置hadoop配置文件中的java<code>[root@node01 hadoop]# vim hadoop-env.sh</code></p></li><li><p>每个节点都修改文件<code>export JAVA_HOME=/root/software/jdk1.8.0_181/bin/java</code></p></li><li><p>勘误：应该是改成<code>export JAVA_HOME=/root/software/jdk1.8.0_181</code><strong>不然hadoop集群起不来</strong></p></li></ul><h3 id="安装Spark"><a href="#安装Spark" class="headerlink" title="安装Spark"></a>安装Spark</h3><ul><li><p>解压<code>[root@node01 software]# tar -zxvf ./spark-2.3.1-bin-hadoop2.6.tgz</code></p></li><li><p>改名<code>[root@node01 software]# mv ./spark-2.3.1-bin-hadoop2.6.tgz  ./spark-2.3.1</code></p></li><li><p>删除安装包<code>[root@node01 software]# rm -rf ./spark-2.3.1-bin-hadoop2.6</code></p></li><li><p>先配置spark的slave，先复制一份<code>[root@node01 conf]# cp slaves.template slaves</code></p></li><li><p><code>[root@node01 conf]# vim slaves</code>添加node02，node03</p></li><li><p><code>[root@node01 conf]# cp spark-env.sh.template spark-env.sh</code></p></li><li><p><code>[root@node01 conf]# vim spark-env.sh</code>，配置相关配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_MASTER_HOST&#x3D;node01</span><br><span class="line">export SPARK_MASTER_PORT&#x3D;7077</span><br><span class="line">export SPARK_WORKER_CORES&#x3D;2</span><br><span class="line">export SPARK_WORKER_MEMORY&#x3D;3g</span><br></pre></td></tr></table></figure></li><li><p>发送spark文件夹到node02，node03节点<code>[root@node01 sbin]# scp -r ./spark-2.3.1/ node03:</code>pwd```</p></li></ul><h3 id="安装Spark客户端"><a href="#安装Spark客户端" class="headerlink" title="安装Spark客户端"></a>安装Spark客户端</h3><ul><li><code>[root@node04 software]# mkdir spark</code></li><li><code>[root@node01 software]# scp -r spark-2.3.1/ node04:</code>pwd``</li><li><code>[root@node04 spark-2.3.1]# cd conf/</code></li><li><code>[root@node04 conf]# rm -f ./slaves</code></li><li><code>[root@node04 conf]# rm -f ./spark-env.sh</code></li></ul><h2 id="对Spark集群进行操作"><a href="#对Spark集群进行操作" class="headerlink" title="对Spark集群进行操作"></a>对Spark集群进行操作</h2><h3 id="运行Spark集群"><a href="#运行Spark集群" class="headerlink" title="运行Spark集群"></a>运行Spark集群</h3><ul><li><p>启动spark集群，首先要进入<code>/root/software/spark-2.3.1/sbin</code>目录下，再<code>[root@node01 sbin]# ./start-all.sh</code></p></li><li><p>进入web端页面查看<code>node01:8080</code></p><p><img src="https://willipic.oss-cn-hangzhou.aliyuncs.com/Spark/sparkweb%E9%A1%B5%E9%9D%A2%E6%9F%A5%E7%9C%8B.png" alt=""></p></li><li><p>关闭集群<code>[root@node01 sbin]# ./stop-all.sh</code></p></li></ul><h3 id="Standalone模式提交任务"><a href="#Standalone模式提交任务" class="headerlink" title="Standalone模式提交任务"></a>Standalone模式提交任务</h3><ul><li>启动集群</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spark-Standalone模式&quot;&gt;&lt;a href=&quot;#Spark-Standalone模式&quot; class=&quot;headerlink&quot; title=&quot;Spark Standalone模式&quot;&gt;&lt;/a&gt;Spark Standalone模式&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;安装配置jdk8&quot;&gt;&lt;a href=&quot;#安装配置jdk8&quot; class=&quot;headerlink&quot; title=&quot;安装配置jdk8&quot;&gt;&lt;/a&gt;安装配置jdk8&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检查jdk版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上传jdk8和Spark2.3.1到node01&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;[root@node01 software]# tar -zxvf ./jdk-8u181-linux-x64.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除jdk安装包&lt;code&gt;[root@node01 software]# rm -rf ./jdk-8u181-linux-x64.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在node01上配置jdk，注意PATH必须放到export jdk前面，不然会导致还是识别老版本的jdk&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Spark" scheme="https://thisiswilli.cn/categories/Spark/"/>
    
    
      <category term="Spark" scheme="https://thisiswilli.cn/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>idea远程连接hadoop进行文件操作</title>
    <link href="https://thisiswilli.cn/2019/02/26/idea%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5hadoop%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://thisiswilli.cn/2019/02/26/idea%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5hadoop%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2019-02-26T11:45:59.000Z</published>
    <updated>2020-02-26T13:00:48.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="idea远程连接hadoop进行文件操作"><a href="#idea远程连接hadoop进行文件操作" class="headerlink" title="idea远程连接hadoop进行文件操作"></a>idea远程连接hadoop进行文件操作</h1><p>部署完高可用集群之后，尝试idea远程连接hadoop进行操作</p><h2 id="配置windows中的hadoop环境"><a href="#配置windows中的hadoop环境" class="headerlink" title="配置windows中的hadoop环境"></a>配置windows中的hadoop环境</h2><ul><li><p>下载hadoop2.6.5到windows中并放在一个纯英文目录下</p></li><li><p>配置环境变量，先系统变量中创建HADOOP_HOME</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAHADOOP_HOME.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAHADOOP_HOME.PNG"></p></li><li><p>创建HADOOP_USER_NAME，名称为集群中的登录名称</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAHADOOP_USER_NAME.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAHADOOP_USER_NAME.PNG"></p></li><li><p>在系统变量的Path中添加%HADOOP_HOME%/bin</p></li><li><p>将hadoop.dll添加到C:\Windows\System32文件夹下</p></li><li><p>在命令行中输入hdfs和hadoop，检测是否安装成功</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/hadoop%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/hadoop%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.PNG"></p></li></ul><h2 id="在idea中配置hadoop"><a href="#在idea中配置hadoop" class="headerlink" title="在idea中配置hadoop"></a>在idea中配置hadoop</h2><ul><li><p>首先下载插件(再次感谢作者)<a href="https://github.com/fangyuzhong2016/HadoopIntellijPlugin，直接clone下来即可，注意项目中所要求的配置信息" target="_blank" rel="noopener">https://github.com/fangyuzhong2016/HadoopIntellijPlugin，直接clone下来即可，注意项目中所要求的配置信息</a></p></li><li><p>idea中创建maven项目</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAmaven%E5%B7%A5%E7%A8%8B.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%88%9B%E5%BB%BAmaven%E5%B7%A5%E7%A8%8B.PNG"></p></li><li><p>工程创建完成之后，File-&gt;Settings-Plugin-&gt;点击右上角的设置-&gt;Install plugin from disk</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%AE%89%E8%A3%85plugins.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E5%AE%89%E8%A3%85plugins.PNG"></p></li><li><p>重启idea，菜单栏中会出现hadoop选项</p></li></ul><h2 id="连接hadoop，进行文件操作"><a href="#连接hadoop，进行文件操作" class="headerlink" title="连接hadoop，进行文件操作"></a>连接hadoop，进行文件操作</h2><ul><li><p>首先开启集群，先<code>zkServer.sh start</code>开启zookeeper，再<code>start-dfs.sh</code>开启全部节点，在配置节点前首先进入node01:50070查看node01和node02的状态。</p></li><li><p>点击idea上方菜单栏中的hadoop进入设置</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E8%AE%BE%E7%BD%AEhadoop%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/%E8%AE%BE%E7%BD%AEhadoop%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.PNG"></p></li><li><p>确定之后左边会出现hadoop</p><p><img src="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/hadoop%E4%BE%A7%E8%BE%B9%E6%A0%8F.PNG" alt="https://raw.githubusercontent.com/ThisisWilli/BigData/master/Hadoop/pic/hadoop%E4%BE%A7%E8%BE%B9%E6%A0%8F.PNG"></p></li><li><p>进行文件操作，代码具体如下，可用junit进行调试，并在hadoop插件中查看hdfs文件系统</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sxt.hdfs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configured;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \* Project: hadoop</span></span><br><span class="line"><span class="comment"> * \* Package: com.sxt.hdfs.test</span></span><br><span class="line"><span class="comment"> * \* Author: Hoodie_Willi</span></span><br><span class="line"><span class="comment"> * \* Date: 2019-07-29 20:36:22</span></span><br><span class="line"><span class="comment"> * \* Description:</span></span><br><span class="line"><span class="comment"> * \</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">null</span>;</span><br><span class="line">    FileSystem fs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conn</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        fs = FileSystem.get(conf);</span><br><span class="line">        <span class="comment">//System.out.println("success");</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = <span class="keyword">new</span> Path(<span class="string">"/mytemp"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fs.exists(path))&#123;</span><br><span class="line">            fs.delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.mkdirs(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//文件上传路径</span></span><br><span class="line">        Path path = <span class="keyword">new</span> Path(<span class="string">"/mytemp/haha.txt"</span>);</span><br><span class="line">        FSDataOutputStream fdos = fs.create(path);</span><br><span class="line">        <span class="comment">//获取磁盘文件</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\IdeaProject\\hadoop\\src\\files\\hello.txt"</span>));</span><br><span class="line">        IOUtils.copyBytes(is, fdos, conf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Path f = <span class="keyword">new</span> Path(<span class="string">"/user/root/test.txt"</span>);</span><br><span class="line">        FileStatus file = fs.getFileStatus(f);</span><br><span class="line"><span class="comment">//        BlockLocation[] blks = fs.getFileBlockLocations(file,0, file.getLen());</span></span><br><span class="line"><span class="comment">//        for (BlockLocation blk : blks)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(blk);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        FSDataInputStream fdis = fs.open(f); <span class="comment">// fileinputstream</span></span><br><span class="line">        fdis.seek(<span class="number">1048576</span>);</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) fdis.readByte());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;idea远程连接hadoop进行文件操作&quot;&gt;&lt;a href=&quot;#idea远程连接hadoop进行文件操作&quot; class=&quot;headerlink&quot; title=&quot;idea远程连接hadoop进行文件操作&quot;&gt;&lt;/a&gt;idea远程连接hadoop进行文件操作&lt;/h1&gt;&lt;p&gt;部署完高可用集群之后，尝试idea远程连接hadoop进行操作&lt;/p&gt;
&lt;h2 id=&quot;配置windows中的hadoop环境&quot;&gt;&lt;a href=&quot;#配置windows中的hadoop环境&quot; class=&quot;headerlink&quot; title=&quot;配置windows中的hadoop环境&quot;&gt;&lt;/a&gt;配置windows中的hadoop环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下载hadoop2.6.5到windows中并放在一个纯英文目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置环境变量，先系统变量中创建HADOOP_HOME&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="https://thisiswilli.cn/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://thisiswilli.cn/tags/Hadoop/"/>
    
  </entry>
  
</feed>
